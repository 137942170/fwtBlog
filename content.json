{"meta":{"title":"snail Blog","subtitle":"常想一二 不思八九","description":"v-log","author":"fwt","url":"https://137942170.github.io/fwtBlog","root":"/fwtBlog/"},"pages":[{"title":"Pic","date":"2019-07-12T06:31:32.000Z","updated":"2019-08-01T03:24:23.305Z","comments":true,"path":"Pic/index.html","permalink":"https://137942170.github.io/fwtBlog/Pic/index.html","excerpt":"","text":"Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('../lib/ins.js') }, 0) })()"},{"title":"categories","date":"2019-06-20T09:41:20.000Z","updated":"2019-07-05T07:45:51.867Z","comments":true,"path":"categories/index.html","permalink":"https://137942170.github.io/fwtBlog/categories/index.html","excerpt":"","text":""},{"title":"个人导航","date":"2019-07-10T06:30:49.000Z","updated":"2019-07-12T06:04:15.054Z","comments":true,"path":"link/index.html","permalink":"https://137942170.github.io/fwtBlog/link/index.html","excerpt":"","text":"IT技术JavaScript前端每日面试题"},{"title":"fwt","date":"2019-06-25T02:04:15.000Z","updated":"2019-07-10T06:55:23.382Z","comments":true,"path":"fwt/index.html","permalink":"https://137942170.github.io/fwtBlog/fwt/index.html","excerpt":"","text":"引言 愿你平安喜乐终遇良人， 愿你不负韶华以梦为马， 愿你历经山河仍觉得人间值得, 愿你历经千帆归来仍是少年。"},{"title":"tags","date":"2019-06-24T04:13:31.000Z","updated":"2019-07-02T10:27:50.891Z","comments":true,"path":"tags/index.html","permalink":"https://137942170.github.io/fwtBlog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-19T07:43:59.102Z","updated":"2019-07-19T07:43:59.102Z","comments":true,"path":"lib/ins.css","permalink":"https://137942170.github.io/fwtBlog/lib/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } figure { margin: 0; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .posts-expand .post-body img { padding: 0; border : 0; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: -webkit-box; display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2019-07-02T09:53:53.731Z","updated":"2019-07-02T08:52:41.199Z","comments":true,"path":"lib/photoswipe/photoswipe.css","permalink":"https://137942170.github.io/fwtBlog/lib/photoswipe/photoswipe.css","excerpt":"","text":"/*! PhotoSwipe main CSS by Dmitry Semenov | photoswipe.com | MIT license */ /* Styles for basic PhotoSwipe functionality (sliding area, open/close transitions) */ /* pswp = photoswipe */ .pswp { display: none; position: absolute; width: 100%; height: 100%; left: 0; top: 0; overflow: hidden; touch-action: none; z-index: 1500; -webkit-text-size-adjust: 100%; /* create separate layer, to avoid paint on window.onscroll in webkit/blink */ -webkit-backface-visibility: hidden; outline: none; } .pswp * { box-sizing: border-box; } .pswp img { max-width: none; } /* style is added when JS option showHideOpacity is set to true */ .pswp--animate_opacity { /* 0.001, because opacity:0 doesn't trigger Paint action, which causes lag at start of transition */ opacity: 0.001; will-change: opacity; /* for open/close transition */ -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp--open { display: block; } .pswp--zoom-allowed .pswp__img { /* autoprefixer: off */ cursor: -webkit-zoom-in; cursor: -moz-zoom-in; cursor: zoom-in; } .pswp--zoomed-in .pswp__img { /* autoprefixer: off */ cursor: -webkit-grab; cursor: -moz-grab; cursor: grab; } .pswp--dragging .pswp__img { /* autoprefixer: off */ cursor: -webkit-grabbing; cursor: -moz-grabbing; cursor: grabbing; } /* Background is added as a separate element. As animating opacity is much faster than animating rgba() background-color. */ .pswp__bg { position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: #000; opacity: 0; -webkit-transform: translateZ(0); transform: translateZ(0); -webkit-backface-visibility: hidden; will-change: opacity; } .pswp__scroll-wrap { position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden; } .pswp__container, .pswp__zoom-wrap { touch-action: none; position: absolute; left: 0; right: 0; top: 0; bottom: 0; } /* Prevent selection and tap highlights */ .pswp__container, .pswp__img { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; } .pswp__zoom-wrap { position: absolute; width: 100%; -webkit-transform-origin: left top; transform-origin: left top; /* for open/close transition */ -webkit-transition: -webkit-transform 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: -webkit-transform 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: transform 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: transform 333ms cubic-bezier(0.4, 0, 0.22, 1), -webkit-transform 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp__bg { will-change: opacity; /* for open/close transition */ -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } .pswp--animated-in .pswp__bg, .pswp--animated-in .pswp__zoom-wrap { -webkit-transition: none; transition: none; } .pswp__container, .pswp__zoom-wrap { -webkit-backface-visibility: hidden; } .pswp__item { position: absolute; left: 0; right: 0; top: 0; bottom: 0; overflow: hidden; } .pswp__img { position: absolute; width: auto; height: auto; top: 0; left: 0; } /* stretched thumbnail or div placeholder element (see below) style is added to avoid flickering in webkit/blink when layers overlap */ .pswp__img--placeholder { -webkit-backface-visibility: hidden; } /* div element that matches size of large image large image loads on top of it */ .pswp__img--placeholder--blank { background: #222; } .pswp--ie .pswp__img { width: 100% !important; height: auto !important; left: 0; top: 0; } /* Error message appears when image is not loaded (JS option errorMsg controls markup) */ .pswp__error-msg { position: absolute; left: 0; top: 50%; width: 100%; text-align: center; font-size: 14px; line-height: 16px; margin-top: -8px; color: #CCC; } .pswp__error-msg a { color: #CCC; text-decoration: underline; }"},{"title":"","date":"2019-07-19T07:53:05.415Z","updated":"2019-07-19T07:53:05.415Z","comments":true,"path":"lib/ins.js","permalink":"https://137942170.github.io/fwtBlog/lib/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { //var minSrc = 'https://raw.githubusercontent.com/yourgithub/Blog_Album/master/min_photos/' + data.link[i]; var minSrc = 'https://raw.githubusercontent.com/https://github.com/137942170/Blog_Album/master/min_photos/' + data.link[i]; // var src = 'https://raw.githubusercontent.com/yourgithub/Blog_Album/master/photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/https://github.com/137942170/Blog_Album/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', '../lib/album/data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { //console.log(\"lazyload\") opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2019-07-02T09:53:53.727Z","updated":"2019-07-02T08:52:41.176Z","comments":true,"path":"lib/default-skin/default-skin.css","permalink":"https://137942170.github.io/fwtBlog/lib/default-skin/default-skin.css","excerpt":"","text":"/*! PhotoSwipe Default UI CSS by Dmitry Semenov | photoswipe.com | MIT license */ /* Contents: 1. Buttons 2. Share modal and links 3. Index indicator (\"1 of X\" counter) 4. Caption 5. Loading indicator 6. Additional styles (root element, top bar, idle state, hidden state, etc.) */ /* 1. Buttons */ /* css reset */ .pswp__button { width: 44px; height: 44px; position: relative; background: none; cursor: pointer; overflow: visible; -webkit-appearance: none; display: block; border: 0; padding: 0; margin: 0; float: right; opacity: 0.75; -webkit-transition: opacity 0.2s; transition: opacity 0.2s; box-shadow: none; } .pswp__button:focus, .pswp__button:hover { opacity: 1; } .pswp__button:active { outline: none; opacity: 0.9; } .pswp__button::-moz-focus-inner { padding: 0; border: 0; } /* pswp__ui--over-close class it added when mouse is over element that should close gallery */ .pswp__ui--over-close .pswp__button--close { opacity: 1; } .pswp__button, .pswp__button--arrow--left:before, .pswp__button--arrow--right:before { background: url(default-skin.png) 0 0 no-repeat; background-size: 264px 88px; width: 44px; height: 44px; } @media (-webkit-min-device-pixel-ratio: 1.1), (-webkit-min-device-pixel-ratio: 1.09375), (min-resolution: 105dpi), (min-resolution: 1.1dppx) { /* Serve SVG sprite if browser supports SVG and resolution is more than 105dpi */ .pswp--svg .pswp__button, .pswp--svg .pswp__button--arrow--left:before, .pswp--svg .pswp__button--arrow--right:before { background-image: url(default-skin.svg); } .pswp--svg .pswp__button--arrow--left, .pswp--svg .pswp__button--arrow--right { background: none; } } .pswp__button--close { background-position: 0 -44px; } .pswp__button--share { background-position: -44px -44px; } .pswp__button--fs { display: none; } .pswp--supports-fs .pswp__button--fs { display: block; } .pswp--fs .pswp__button--fs { background-position: -44px 0; } .pswp__button--zoom { display: none; background-position: -88px 0; } .pswp--zoom-allowed .pswp__button--zoom { display: block; } .pswp--zoomed-in .pswp__button--zoom { background-position: -132px 0; } /* no arrows on touch screens */ .pswp--touch .pswp__button--arrow--left, .pswp--touch .pswp__button--arrow--right { visibility: hidden; } /* Arrow buttons hit area (icon is added to :before pseudo-element) */ .pswp__button--arrow--left, .pswp__button--arrow--right { background: none; top: 50%; margin-top: -50px; width: 70px; height: 100px; position: absolute; } .pswp__button--arrow--left { left: 0; } .pswp__button--arrow--right { right: 0; } .pswp__button--arrow--left:before, .pswp__button--arrow--right:before { content: ''; top: 35px; background-color: rgba(0, 0, 0, 0.3); height: 30px; width: 32px; position: absolute; } .pswp__button--arrow--left:before { left: 6px; background-position: -138px -44px; } .pswp__button--arrow--right:before { right: 6px; background-position: -94px -44px; } /* 2. Share modal/popup and links */ .pswp__counter, .pswp__share-modal { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .pswp__share-modal { display: block; background: rgba(0, 0, 0, 0.5); width: 100%; height: 100%; top: 0; left: 0; padding: 10px; position: absolute; z-index: 1600; opacity: 0; -webkit-transition: opacity 0.25s ease-out; transition: opacity 0.25s ease-out; -webkit-backface-visibility: hidden; will-change: opacity; } .pswp__share-modal--hidden { display: none; } .pswp__share-tooltip { z-index: 1620; position: absolute; background: #FFF; top: 56px; border-radius: 2px; display: block; width: auto; right: 44px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25); -webkit-transform: translateY(6px); transform: translateY(6px); -webkit-transition: -webkit-transform 0.25s; transition: -webkit-transform 0.25s; transition: transform 0.25s; transition: transform 0.25s, -webkit-transform 0.25s; -webkit-backface-visibility: hidden; will-change: transform; } .pswp__share-tooltip a { display: block; padding: 8px 12px; color: #000; text-decoration: none; font-size: 14px; line-height: 18px; } .pswp__share-tooltip a:hover { text-decoration: none; color: #000; } .pswp__share-tooltip a:first-child { /* round corners on the first/last list item */ border-radius: 2px 2px 0 0; } .pswp__share-tooltip a:last-child { border-radius: 0 0 2px 2px; } .pswp__share-modal--fade-in { opacity: 1; } .pswp__share-modal--fade-in .pswp__share-tooltip { -webkit-transform: translateY(0); transform: translateY(0); } /* increase size of share links on touch devices */ .pswp--touch .pswp__share-tooltip a { padding: 16px 12px; } a.pswp__share--facebook:before { content: ''; display: block; width: 0; height: 0; position: absolute; top: -12px; right: 15px; border: 6px solid transparent; border-bottom-color: #FFF; -webkit-pointer-events: none; -moz-pointer-events: none; pointer-events: none; } a.pswp__share--facebook:hover { background: #3E5C9A; color: #FFF; } a.pswp__share--facebook:hover:before { border-bottom-color: #3E5C9A; } a.pswp__share--twitter:hover { background: #55ACEE; color: #FFF; } a.pswp__share--pinterest:hover { background: #CCC; color: #CE272D; } a.pswp__share--download:hover { background: #DDD; } /* 3. Index indicator (\"1 of X\" counter) */ .pswp__counter { position: absolute; left: 0; top: 0; height: 44px; font-size: 13px; line-height: 44px; color: #FFF; opacity: 0.75; padding: 0 10px; } /* 4. Caption */ .pswp__caption { position: absolute; left: 0; bottom: 0; width: 100%; min-height: 44px; } .pswp__caption small { font-size: 11px; color: #BBB; } .pswp__caption__center { text-align: left; max-width: 420px; margin: 0 auto; font-size: 13px; padding: 10px; line-height: 20px; color: #CCC; } .pswp__caption--empty { display: none; } /* Fake caption element, used to calculate height of next/prev image */ .pswp__caption--fake { visibility: hidden; } /* 5. Loading indicator (preloader) You can play with it here - http://codepen.io/dimsemenov/pen/yyBWoR */ .pswp__preloader { width: 44px; height: 44px; position: absolute; top: 0; left: 50%; margin-left: -22px; opacity: 0; -webkit-transition: opacity 0.25s ease-out; transition: opacity 0.25s ease-out; will-change: opacity; direction: ltr; } .pswp__preloader__icn { width: 20px; height: 20px; margin: 12px; } .pswp__preloader--active { opacity: 1; } .pswp__preloader--active .pswp__preloader__icn { /* We use .gif in browsers that don't support CSS animation */ background: url(preloader.gif) 0 0 no-repeat; } .pswp--css_animation .pswp__preloader--active { opacity: 1; } .pswp--css_animation .pswp__preloader--active .pswp__preloader__icn { -webkit-animation: clockwise 500ms linear infinite; animation: clockwise 500ms linear infinite; } .pswp--css_animation .pswp__preloader--active .pswp__preloader__donut { -webkit-animation: donut-rotate 1000ms cubic-bezier(0.4, 0, 0.22, 1) infinite; animation: donut-rotate 1000ms cubic-bezier(0.4, 0, 0.22, 1) infinite; } .pswp--css_animation .pswp__preloader__icn { background: none; opacity: 0.75; width: 14px; height: 14px; position: absolute; left: 15px; top: 15px; margin: 0; } .pswp--css_animation .pswp__preloader__cut { /* The idea of animating inner circle is based on Polymer (\"material\") loading indicator by Keanu Lee https://blog.keanulee.com/2014/10/20/the-tale-of-three-spinners.html */ position: relative; width: 7px; height: 14px; overflow: hidden; } .pswp--css_animation .pswp__preloader__donut { box-sizing: border-box; width: 14px; height: 14px; border: 2px solid #FFF; border-radius: 50%; border-left-color: transparent; border-bottom-color: transparent; position: absolute; top: 0; left: 0; background: none; margin: 0; } @media screen and (max-width: 1024px) { .pswp__preloader { position: relative; left: auto; top: auto; margin: 0; float: right; } } @-webkit-keyframes clockwise { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes clockwise { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @-webkit-keyframes donut-rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0); } 50% { -webkit-transform: rotate(-140deg); transform: rotate(-140deg); } 100% { -webkit-transform: rotate(0); transform: rotate(0); } } @keyframes donut-rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0); } 50% { -webkit-transform: rotate(-140deg); transform: rotate(-140deg); } 100% { -webkit-transform: rotate(0); transform: rotate(0); } } /* 6. Additional styles */ /* root element of UI */ .pswp__ui { -webkit-font-smoothing: auto; visibility: visible; opacity: 1; z-index: 1550; } /* top black bar with buttons and \"1 of X\" indicator */ .pswp__top-bar { position: absolute; left: 0; top: 0; height: 44px; width: 100%; } .pswp__caption, .pswp__top-bar, .pswp--has_mouse .pswp__button--arrow--left, .pswp--has_mouse .pswp__button--arrow--right { -webkit-backface-visibility: hidden; will-change: opacity; -webkit-transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); transition: opacity 333ms cubic-bezier(0.4, 0, 0.22, 1); } /* pswp--has_mouse class is added only when two subsequent mousemove events occur */ .pswp--has_mouse .pswp__button--arrow--left, .pswp--has_mouse .pswp__button--arrow--right { visibility: visible; } .pswp__top-bar, .pswp__caption { background-color: rgba(0, 0, 0, 0.5); } /* pswp__ui--fit class is added when main image \"fits\" between top bar and bottom bar (caption) */ .pswp__ui--fit .pswp__top-bar, .pswp__ui--fit .pswp__caption { background-color: rgba(0, 0, 0, 0.3); } /* pswp__ui--idle class is added when mouse isn't moving for several seconds (JS option timeToIdle) */ .pswp__ui--idle .pswp__top-bar { opacity: 0; } .pswp__ui--idle .pswp__button--arrow--left, .pswp__ui--idle .pswp__button--arrow--right { opacity: 0; } /* pswp__ui--hidden class is added when controls are hidden e.g. when user taps to toggle visibility of controls */ .pswp__ui--hidden .pswp__top-bar, .pswp__ui--hidden .pswp__caption, .pswp__ui--hidden .pswp__button--arrow--left, .pswp__ui--hidden .pswp__button--arrow--right { /* Force paint & create composition layer for controls. */ opacity: 0.001; } /* pswp__ui--one-slide class is added when there is just one item in gallery */ .pswp__ui--one-slide .pswp__button--arrow--left, .pswp__ui--one-slide .pswp__button--arrow--right, .pswp__ui--one-slide .pswp__counter { display: none; } .pswp__element--disabled { display: none !important; } .pswp--minimal--dark .pswp__top-bar { background: none; }"},{"title":"","date":"2019-07-02T09:53:53.730Z","updated":"2019-07-02T08:52:41.198Z","comments":true,"path":"lib/photoswipe/photoswipe-ui-default.min.js","permalink":"https://137942170.github.io/fwtBlog/lib/photoswipe/photoswipe-ui-default.min.js","excerpt":"","text":"/*! PhotoSwipe Default UI - 4.1.2 - 2017-04-05 * http://photoswipe.com * Copyright (c) 2017 Dmitry Semenov; */ !function(a,b){\"function\"==typeof define&&define.amd?define(b):\"object\"==typeof exports?module.exports=b():a.PhotoSwipeUI_Default=b()}(this,function(){\"use strict\";var a=function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v=this,w=!1,x=!0,y=!0,z={barsSize:{top:44,bottom:\"auto\"},closeElClasses:[\"item\",\"caption\",\"zoom-wrap\",\"ui\",\"top-bar\"],timeToIdle:4e3,timeToIdleOutside:1e3,loadingIndicatorDelay:1e3,addCaptionHTMLFn:function(a,b){return a.title?(b.children[0].innerHTML=a.title,!0):(b.children[0].innerHTML=\"\",!1)},closeEl:!0,captionEl:!0,fullscreenEl:!0,zoomEl:!0,shareEl:!0,counterEl:!0,arrowEl:!0,preloaderEl:!0,tapToClose:!1,tapToToggleControls:!0,clickToCloseNonZoomable:!0,shareButtons:[{id:\"facebook\",label:\"Share on Facebook\",url:\"https://www.facebook.com/sharer/sharer.php?u=\"},{id:\"twitter\",label:\"Tweet\",url:\"https://twitter.com/intent/tweet?text=&url=\"},{id:\"pinterest\",label:\"Pin it\",url:\"http://www.pinterest.com/pin/create/button/?url=&media=&description=\"},{id:\"download\",label:\"Download image\",url:\"\",download:!0}],getImageURLForShare:function(){return a.currItem.src||\"\"},getPageURLForShare:function(){return window.location.href},getTextForShare:function(){return a.currItem.title||\"\"},indexIndicatorSep:\" / \",fitControlsWidth:1200},A=function(a){if(r)return!0;a=a||window.event,q.timeToIdle&&q.mouseUsed&&!k&&K();for(var c,d,e=a.target||a.srcElement,f=e.getAttribute(\"class\")||\"\",g=0;g-1&&(c.onTap(),d=!0);if(d){a.stopPropagation&&a.stopPropagation(),r=!0;var h=b.features.isOldAndroid?600:30;s=setTimeout(function(){r=!1},h)}},B=function(){return!a.likelyTouchDevice||q.mouseUsed||screen.width>q.fitControlsWidth},C=function(a,c,d){b[(d?\"add\":\"remove\")+\"Class\"](a,\"pswp__\"+c)},D=function(){var a=1===q.getNumItemsFn();a!==p&&(C(d,\"ui--one-slide\",a),p=a)},E=function(){C(i,\"share-modal--hidden\",y)},F=function(){return y=!y,y?(b.removeClass(i,\"pswp__share-modal--fade-in\"),setTimeout(function(){y&&E()},300)):(E(),setTimeout(function(){y||b.addClass(i,\"pswp__share-modal--fade-in\")},30)),y||H(),!1},G=function(b){b=b||window.event;var c=b.target||b.srcElement;return a.shout(\"shareLinkClick\",b,c),!!c.href&&(!!c.hasAttribute(\"download\")||(window.open(c.href,\"pswp_share\",\"scrollbars=yes,resizable=yes,toolbar=no,location=yes,width=550,height=420,top=100,left=\"+(window.screen?Math.round(screen.width/2-275):100)),y||F(),!1))},H=function(){for(var a,b,c,d,e,f=\"\",g=0;g-1&&(d.getAttribute(\"class\").indexOf(\"__caption\")>0||/(SMALL|STRONG|EM)/i.test(d.tagName))&&(c.prevent=!1)}),l(\"bindEvents\",function(){b.bind(d,\"pswpTap click\",A),b.bind(a.scrollWrap,\"pswpTap\",v.onGlobalTap),a.likelyTouchDevice||b.bind(a.scrollWrap,\"mouseover\",v.onMouseOver)}),l(\"unbindEvents\",function(){y||F(),t&&clearInterval(t),b.unbind(document,\"mouseout\",L),b.unbind(document,\"mousemove\",K),b.unbind(d,\"pswpTap click\",A),b.unbind(a.scrollWrap,\"pswpTap\",v.onGlobalTap),b.unbind(a.scrollWrap,\"mouseover\",v.onMouseOver),c&&(b.unbind(document,c.eventK,v.updateFullscreen),c.isFullscreen()&&(q.hideAnimationDuration=0,c.exit()),c=null)}),l(\"destroy\",function(){q.captionEl&&(f&&d.removeChild(f),b.removeClass(e,\"pswp__caption--empty\")),i&&(i.children[0].onclick=null),b.removeClass(d,\"pswp__ui--over-close\"),b.addClass(d,\"pswp__ui--hidden\"),v.setIdle(!1)}),q.showAnimationDuration||b.removeClass(d,\"pswp__ui--hidden\"),l(\"initialZoomIn\",function(){q.showAnimationDuration&&b.removeClass(d,\"pswp__ui--hidden\")}),l(\"initialZoomOut\",function(){b.addClass(d,\"pswp__ui--hidden\")}),l(\"parseVerticalMargin\",P),T(),q.shareEl&&h&&i&&(y=!0),D(),Q(),M(),N()},v.setIdle=function(a){k=a,C(d,\"ui--idle\",a)},v.update=function(){x&&a.currItem?(v.updateIndexIndicator(),q.captionEl&&(q.addCaptionHTMLFn(a.currItem,e),C(e,\"caption--empty\",!a.currItem.title)),w=!0):w=!1,y||F(),D()},v.updateFullscreen=function(d){d&&setTimeout(function(){a.setScrollOffset(0,b.getScrollY())},50),b[(c.isFullscreen()?\"add\":\"remove\")+\"Class\"](a.template,\"pswp--fs\")},v.updateIndexIndicator=function(){q.counterEl&&(g.innerHTML=a.getCurrentIndex()+1+q.indexIndicatorSep+q.getNumItemsFn())},v.onGlobalTap=function(c){c=c||window.event;var d=c.target||c.srcElement;if(!r)if(c.detail&&\"mouse\"===c.detail.pointerType){if(I(d))return void a.close();b.hasClass(d,\"pswp__img\")&&(1===a.getZoomLevel()&&a.getZoomLevel()"},{"title":"","date":"2019-07-02T09:53:53.729Z","updated":"2019-07-02T08:52:41.185Z","comments":true,"path":"lib/photoswipe/photoswipe-ui-default.js","permalink":"https://137942170.github.io/fwtBlog/lib/photoswipe/photoswipe-ui-default.js","excerpt":"","text":"/*! PhotoSwipe Default UI - 4.1.2 - 2017-04-05 * http://photoswipe.com * Copyright (c) 2017 Dmitry Semenov; */ /** * * UI on top of main sliding area (caption, arrows, close button, etc.). * Built just using public methods/properties of PhotoSwipe. * */ (function (root, factory) { if (typeof define === 'function' && define.amd) { define(factory); } else if (typeof exports === 'object') { module.exports = factory(); } else { root.PhotoSwipeUI_Default = factory(); } })(this, function () { 'use strict'; var PhotoSwipeUI_Default = function(pswp, framework) { var ui = this; var _overlayUIUpdated = false, _controlsVisible = true, _fullscrenAPI, _controls, _captionContainer, _fakeCaptionContainer, _indexIndicator, _shareButton, _shareModal, _shareModalHidden = true, _initalCloseOnScrollValue, _isIdle, _listen, _loadingIndicator, _loadingIndicatorHidden, _loadingIndicatorTimeout, _galleryHasOneSlide, _options, _defaultUIOptions = { barsSize: {top:44, bottom:'auto'}, closeElClasses: ['item', 'caption', 'zoom-wrap', 'ui', 'top-bar'], timeToIdle: 4000, timeToIdleOutside: 1000, loadingIndicatorDelay: 1000, // 2s addCaptionHTMLFn: function(item, captionEl /*, isFake */) { if(!item.title) { captionEl.children[0].innerHTML = ''; return false; } captionEl.children[0].innerHTML = item.title; return true; }, closeEl:true, captionEl: true, fullscreenEl: true, zoomEl: true, shareEl: true, counterEl: true, arrowEl: true, preloaderEl: true, tapToClose: false, tapToToggleControls: true, clickToCloseNonZoomable: true, shareButtons: [ {id:'facebook', label:'Share on Facebook', url:'https://www.facebook.com/sharer/sharer.php?u='}, {id:'twitter', label:'Tweet', url:'https://twitter.com/intent/tweet?text=&url='}, {id:'pinterest', label:'Pin it', url:'http://www.pinterest.com/pin/create/button/'+ '?url=&media=&description='}, {id:'download', label:'Download image', url:'', download:true} ], getImageURLForShare: function( /* shareButtonData */ ) { return pswp.currItem.src || ''; }, getPageURLForShare: function( /* shareButtonData */ ) { return window.location.href; }, getTextForShare: function( /* shareButtonData */ ) { return pswp.currItem.title || ''; }, indexIndicatorSep: ' / ', fitControlsWidth: 1200 }, _blockControlsTap, _blockControlsTapTimeout; var _onControlsTap = function(e) { if(_blockControlsTap) { return true; } e = e || window.event; if(_options.timeToIdle && _options.mouseUsed && !_isIdle) { // reset idle timer _onIdleMouseMove(); } var target = e.target || e.srcElement, uiElement, clickedClass = target.getAttribute('class') || '', found; for(var i = 0; i < _uiElements.length; i++) { uiElement = _uiElements[i]; if(uiElement.onTap && clickedClass.indexOf('pswp__' + uiElement.name ) > -1 ) { uiElement.onTap(); found = true; } } if(found) { if(e.stopPropagation) { e.stopPropagation(); } _blockControlsTap = true; // Some versions of Android don't prevent ghost click event // when preventDefault() was called on touchstart and/or touchend. // // This happens on v4.3, 4.2, 4.1, // older versions strangely work correctly, // but just in case we add delay on all of them) var tapDelay = framework.features.isOldAndroid ? 600 : 30; _blockControlsTapTimeout = setTimeout(function() { _blockControlsTap = false; }, tapDelay); } }, _fitControlsInViewport = function() { return !pswp.likelyTouchDevice || _options.mouseUsed || screen.width > _options.fitControlsWidth; }, _togglePswpClass = function(el, cName, add) { framework[ (add ? 'add' : 'remove') + 'Class' ](el, 'pswp__' + cName); }, // add class when there is just one item in the gallery // (by default it hides left/right arrows and 1ofX counter) _countNumItems = function() { var hasOneSlide = (_options.getNumItemsFn() === 1); if(hasOneSlide !== _galleryHasOneSlide) { _togglePswpClass(_controls, 'ui--one-slide', hasOneSlide); _galleryHasOneSlide = hasOneSlide; } }, _toggleShareModalClass = function() { _togglePswpClass(_shareModal, 'share-modal--hidden', _shareModalHidden); }, _toggleShareModal = function() { _shareModalHidden = !_shareModalHidden; if(!_shareModalHidden) { _toggleShareModalClass(); setTimeout(function() { if(!_shareModalHidden) { framework.addClass(_shareModal, 'pswp__share-modal--fade-in'); } }, 30); } else { framework.removeClass(_shareModal, 'pswp__share-modal--fade-in'); setTimeout(function() { if(_shareModalHidden) { _toggleShareModalClass(); } }, 300); } if(!_shareModalHidden) { _updateShareURLs(); } return false; }, _openWindowPopup = function(e) { e = e || window.event; var target = e.target || e.srcElement; pswp.shout('shareLinkClick', e, target); if(!target.href) { return false; } if( target.hasAttribute('download') ) { return true; } window.open(target.href, 'pswp_share', 'scrollbars=yes,resizable=yes,toolbar=no,'+ 'location=yes,width=550,height=420,top=100,left=' + (window.screen ? Math.round(screen.width / 2 - 275) : 100) ); if(!_shareModalHidden) { _toggleShareModal(); } return false; }, _updateShareURLs = function() { var shareButtonOut = '', shareButtonData, shareURL, image_url, page_url, share_text; for(var i = 0; i < _options.shareButtons.length; i++) { shareButtonData = _options.shareButtons[i]; image_url = _options.getImageURLForShare(shareButtonData); page_url = _options.getPageURLForShare(shareButtonData); share_text = _options.getTextForShare(shareButtonData); shareURL = shareButtonData.url.replace('', encodeURIComponent(page_url) ) .replace('', encodeURIComponent(image_url) ) .replace('', image_url ) .replace('', encodeURIComponent(share_text) ); shareButtonOut += '= 0.95) { ui.showControls(); } }); // Hide controls when pinching to close var pinchControlsHidden; _listen('onPinchClose' , function(now) { if(_controlsVisible && now < 0.9) { ui.hideControls(); pinchControlsHidden = true; } else if(pinchControlsHidden && !_controlsVisible && now > 0.9) { ui.showControls(); } }); _listen('zoomGestureEnded', function() { pinchControlsHidden = false; if(pinchControlsHidden && !_controlsVisible) { ui.showControls(); } }); }; var _uiElements = [ { name: 'caption', option: 'captionEl', onInit: function(el) { _captionContainer = el; } }, { name: 'share-modal', option: 'shareEl', onInit: function(el) { _shareModal = el; }, onTap: function() { _toggleShareModal(); } }, { name: 'button--share', option: 'shareEl', onInit: function(el) { _shareButton = el; }, onTap: function() { _toggleShareModal(); } }, { name: 'button--zoom', option: 'zoomEl', onTap: pswp.toggleDesktopZoom }, { name: 'counter', option: 'counterEl', onInit: function(el) { _indexIndicator = el; } }, { name: 'button--close', option: 'closeEl', onTap: pswp.close }, { name: 'button--arrow--left', option: 'arrowEl', onTap: pswp.prev }, { name: 'button--arrow--right', option: 'arrowEl', onTap: pswp.next }, { name: 'button--fs', option: 'fullscreenEl', onTap: function() { if(_fullscrenAPI.isFullscreen()) { _fullscrenAPI.exit(); } else { _fullscrenAPI.enter(); } } }, { name: 'preloader', option: 'preloaderEl', onInit: function(el) { _loadingIndicator = el; } } ]; var _setupUIElements = function() { var item, classAttr, uiElement; var loopThroughChildElements = function(sChildren) { if(!sChildren) { return; } var l = sChildren.length; for(var i = 0; i < l; i++) { item = sChildren[i]; classAttr = item.className; for(var a = 0; a < _uiElements.length; a++) { uiElement = _uiElements[a]; if(classAttr.indexOf('pswp__' + uiElement.name) > -1 ) { if( _options[uiElement.option] ) { // if element is not disabled from options framework.removeClass(item, 'pswp__element--disabled'); if(uiElement.onInit) { uiElement.onInit(item); } //item.style.display = 'block'; } else { framework.addClass(item, 'pswp__element--disabled'); //item.style.display = 'none'; } } } } }; loopThroughChildElements(_controls.children); var topBar = framework.getChildByClass(_controls, 'pswp__top-bar'); if(topBar) { loopThroughChildElements( topBar.children ); } }; ui.init = function() { // extend options framework.extend(pswp.options, _defaultUIOptions, true); // create local link for fast access _options = pswp.options; // find pswp__ui element _controls = framework.getChildByClass(pswp.scrollWrap, 'pswp__ui'); // create local link _listen = pswp.listen; _setupHidingControlsDuringGestures(); // update controls when slides change _listen('beforeChange', ui.update); // toggle zoom on double-tap _listen('doubleTap', function(point) { var initialZoomLevel = pswp.currItem.initialZoomLevel; if(pswp.getZoomLevel() !== initialZoomLevel) { pswp.zoomTo(initialZoomLevel, point, 333); } else { pswp.zoomTo(_options.getDoubleTapZoom(false, pswp.currItem), point, 333); } }); // Allow text selection in caption _listen('preventDragEvent', function(e, isDown, preventObj) { var t = e.target || e.srcElement; if( t && t.getAttribute('class') && e.type.indexOf('mouse') > -1 && ( t.getAttribute('class').indexOf('__caption') > 0 || (/(SMALL|STRONG|EM)/i).test(t.tagName) ) ) { preventObj.prevent = false; } }); // bind events for UI _listen('bindEvents', function() { framework.bind(_controls, 'pswpTap click', _onControlsTap); framework.bind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap); if(!pswp.likelyTouchDevice) { framework.bind(pswp.scrollWrap, 'mouseover', ui.onMouseOver); } }); // unbind events for UI _listen('unbindEvents', function() { if(!_shareModalHidden) { _toggleShareModal(); } if(_idleInterval) { clearInterval(_idleInterval); } framework.unbind(document, 'mouseout', _onMouseLeaveWindow); framework.unbind(document, 'mousemove', _onIdleMouseMove); framework.unbind(_controls, 'pswpTap click', _onControlsTap); framework.unbind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap); framework.unbind(pswp.scrollWrap, 'mouseover', ui.onMouseOver); if(_fullscrenAPI) { framework.unbind(document, _fullscrenAPI.eventK, ui.updateFullscreen); if(_fullscrenAPI.isFullscreen()) { _options.hideAnimationDuration = 0; _fullscrenAPI.exit(); } _fullscrenAPI = null; } }); // clean up things when gallery is destroyed _listen('destroy', function() { if(_options.captionEl) { if(_fakeCaptionContainer) { _controls.removeChild(_fakeCaptionContainer); } framework.removeClass(_captionContainer, 'pswp__caption--empty'); } if(_shareModal) { _shareModal.children[0].onclick = null; } framework.removeClass(_controls, 'pswp__ui--over-close'); framework.addClass( _controls, 'pswp__ui--hidden'); ui.setIdle(false); }); if(!_options.showAnimationDuration) { framework.removeClass( _controls, 'pswp__ui--hidden'); } _listen('initialZoomIn', function() { if(_options.showAnimationDuration) { framework.removeClass( _controls, 'pswp__ui--hidden'); } }); _listen('initialZoomOut', function() { framework.addClass( _controls, 'pswp__ui--hidden'); }); _listen('parseVerticalMargin', _applyNavBarGaps); _setupUIElements(); if(_options.shareEl && _shareButton && _shareModal) { _shareModalHidden = true; } _countNumItems(); _setupIdle(); _setupFullscreenAPI(); _setupLoadingIndicator(); }; ui.setIdle = function(isIdle) { _isIdle = isIdle; _togglePswpClass(_controls, 'ui--idle', isIdle); }; ui.update = function() { // Don't update UI if it's hidden if(_controlsVisible && pswp.currItem) { ui.updateIndexIndicator(); if(_options.captionEl) { _options.addCaptionHTMLFn(pswp.currItem, _captionContainer); _togglePswpClass(_captionContainer, 'caption--empty', !pswp.currItem.title); } _overlayUIUpdated = true; } else { _overlayUIUpdated = false; } if(!_shareModalHidden) { _toggleShareModal(); } _countNumItems(); }; ui.updateFullscreen = function(e) { if(e) { // some browsers change window scroll position during the fullscreen // so PhotoSwipe updates it just in case setTimeout(function() { pswp.setScrollOffset( 0, framework.getScrollY() ); }, 50); } // toogle pswp--fs class on root element framework[ (_fullscrenAPI.isFullscreen() ? 'add' : 'remove') + 'Class' ](pswp.template, 'pswp--fs'); }; ui.updateIndexIndicator = function() { if(_options.counterEl) { _indexIndicator.innerHTML = (pswp.getCurrentIndex()+1) + _options.indexIndicatorSep + _options.getNumItemsFn(); } }; ui.onGlobalTap = function(e) { e = e || window.event; var target = e.target || e.srcElement; if(_blockControlsTap) { return; } if(e.detail && e.detail.pointerType === 'mouse') { // close gallery if clicked outside of the image if(_hasCloseClass(target)) { pswp.close(); return; } if(framework.hasClass(target, 'pswp__img')) { if(pswp.getZoomLevel() === 1 && pswp.getZoomLevel()"},{"title":"","date":"2019-07-02T09:53:53.732Z","updated":"2019-07-02T08:52:41.204Z","comments":true,"path":"lib/photoswipe/photoswipe.min.js","permalink":"https://137942170.github.io/fwtBlog/lib/photoswipe/photoswipe.min.js","excerpt":"","text":"/*! PhotoSwipe - v4.1.2 - 2017-04-05 * http://photoswipe.com * Copyright (c) 2017 Dmitry Semenov; */ !function(a,b){\"function\"==typeof define&&define.amd?define(b):\"object\"==typeof exports?module.exports=b():a.PhotoSwipe=b()}(this,function(){\"use strict\";var a=function(a,b,c,d){var e={features:null,bind:function(a,b,c,d){var e=(d?\"remove\":\"add\")+\"EventListener\";b=b.split(\" \");for(var f=0;f0&&(g=parseInt(g[1],10),g>=1&&g=1&&(i=ac()-1&&d0?i.maxSpreadZoom:1},Va=function(a,b,c,d){return d===f.currItem.initialZoomLevel?(c[a]=f.currItem.initialPosition[a],!0):(c[a]=La(a,d),c[a]>b.min[a]?(c[a]=b.min[a],!0):c[a]1?1:a.fitRatio,c=a.container.style,d=b*a.w,e=b*a.h;c.width=d+\"px\",c.height=e+\"px\",c.left=a.initialPosition.x+\"px\",c.top=a.initialPosition.y+\"px\"},Ha=function(){if(ea){var a=ea,b=f.currItem,c=b.fitRatio>1?1:b.fitRatio,d=c*b.w,e=c*b.h;a.width=d+\"px\",a.height=e+\"px\",a.left=pa.x+\"px\",a.top=pa.y+\"px\"}}},Xa=function(a){var b=\"\";i.escKey&&27===a.keyCode?b=\"close\":i.arrowKeys&&(37===a.keyCode?b=\"prev\":39===a.keyCode&&(b=\"next\")),b&&(a.ctrlKey||a.altKey||a.shiftKey||a.metaKey||(a.preventDefault?a.preventDefault():a.returnValue=!1,f[b]()))},Ya=function(a){a&&(Y||X||fa||T)&&(a.preventDefault(),a.stopPropagation())},Za=function(){f.setScrollOffset(0,e.getScrollY())},$a={},_a=0,ab=function(a){$a[a]&&($a[a].raf&&I($a[a].raf),_a--,delete $a[a])},bb=function(a){$a[a]&&ab(a),$a[a]||(_a++,$a[a]={})},cb=function(){for(var a in $a)$a.hasOwnProperty(a)&&ab(a)},db=function(a,b,c,d,e,f,g){var h,i=Ea();bb(a);var j=function(){if($a[a]){if(h=Ea()-i,h>=d)return ab(a),f(c),void(g&&g());f((c-b)*e(h/d)+b),$a[a].raf=H(j)}};j()},eb={shout:Da,listen:Ca,viewportSize:qa,options:i,isMainScrollAnimating:function(){return fa},getZoomLevel:function(){return s},getCurrentIndex:function(){return m},isDragging:function(){return V},isZooming:function(){return aa},setScrollOffset:function(a,b){sa.x=a,M=sa.y=b,Da(\"updateScrollOffset\",sa)},applyZoomPan:function(a,b,c,d){pa.x=b,pa.y=c,s=a,Ha(d)},init:function(){if(!j&&!k){var c;f.framework=e,f.template=a,f.bg=e.getChildByClass(a,\"pswp__bg\"),J=a.className,j=!0,N=e.detectFeatures(),H=N.raf,I=N.caf,E=N.transform,L=N.oldIE,f.scrollWrap=e.getChildByClass(a,\"pswp__scroll-wrap\"),f.container=e.getChildByClass(f.scrollWrap,\"pswp__container\"),n=f.container.style,f.itemHolders=y=[{el:f.container.children[0],wrap:0,index:-1},{el:f.container.children[1],wrap:0,index:-1},{el:f.container.children[2],wrap:0,index:-1}],y[0].el.style.display=y[2].el.style.display=\"none\",Wa(),r={resize:f.updateSize,orientationchange:function(){clearTimeout(O),O=setTimeout(function(){qa.x!==f.scrollWrap.clientWidth&&f.updateSize()},500)},scroll:Za,keydown:Xa,click:Ya};var d=N.isOldIOSPhone||N.isOldAndroid||N.isMobileOpera;for(N.animationName&&N.transform&&!d||(i.showAnimationDuration=i.hideAnimationDuration=0),c=0;c=ac())&&(m=0),f.currItem=_b(m),(N.isOldIOSPhone||N.isOldAndroid)&&(va=!1),a.setAttribute(\"aria-hidden\",\"false\"),i.modal&&(va?a.style.position=\"fixed\":(a.style.position=\"absolute\",a.style.top=e.getScrollY()+\"px\")),void 0===M&&(Da(\"initialLayout\"),M=K=e.getScrollY());var l=\"pswp--open \";for(i.mainClass&&(l+=i.mainClass+\" \"),i.showHideOpacity&&(l+=\"pswp--animate_opacity \"),l+=G?\"pswp--touch\":\"pswp--notouch\",l+=N.animationName?\" pswp--css_animation\":\"\",l+=N.svg?\" pswp--svg\":\"\",e.addClass(a,l),f.updateSize(),o=-1,ua=null,c=0;cda.min.x?a=da.min.x:ada.min.y?b=da.min.y:b=h&&(o+=ua+(ua>0?-h:h),c=h);for(var d=0;d0?(b=y.shift(),y[h-1]=b,o++,Ja((o+2)*ta.x,b.el.style),f.setContent(b,m-c+d+1+1)):(b=y.pop(),y.unshift(b),o--,Ja(o*ta.x,b.el.style),f.setContent(b,m+c-d-1-1));if(ea&&1===Math.abs(ua)){var e=_b(z);e.initialZoomLevel!==s&&(ic(e,qa),mc(e),Ia(e))}ua=0,f.updateCurrZoomItem(),z=m,Da(\"afterChange\")}}},updateSize:function(b){if(!va&&i.modal){var c=e.getScrollY();if(M!==c&&(a.style.top=c+\"px\",M=c),!b&&xa.x===window.innerWidth&&xa.y===window.innerHeight)return;xa.x=window.innerWidth,xa.y=window.innerHeight,a.style.height=xa.y+\"px\"}if(qa.x=f.scrollWrap.clientWidth,qa.y=f.scrollWrap.clientHeight,Za(),ta.x=qa.x+Math.round(qa.x*i.spacing),ta.y=qa.y,Ka(ta.x*ra),Da(\"beforeResize\"),void 0!==o){for(var d,g,j,k=0;k2&&(j=Aa(j)),g=_b(j),g&&(x||g.needsUpdate||!g.bounds)?(f.cleanSlide(g),f.setContent(d,j),1===k&&(f.currItem=g,f.updateCurrZoomItem(!0)),g.needsUpdate=!1):d.index===-1&&j>=0&&f.setContent(d,j),g&&g.container&&(ic(g,qa),mc(g),Ia(g));x=!1}t=s=f.currItem.initialZoomLevel,da=f.currItem.bounds,da&&(pa.x=da.center.x,pa.y=da.center.y,Ha(!0)),Da(\"resize\")},zoomTo:function(a,b,c,d,f){b&&(t=s,ub.x=Math.abs(b.x)-pa.x,ub.y=Math.abs(b.y)-pa.y,Ma(oa,pa));var g=Sa(a,!1),h={};Va(\"x\",g,h,a),Va(\"y\",g,h,a);var i=s,j={x:pa.x,y:pa.y};Na(h);var k=function(b){1===b?(s=a,pa.x=h.x,pa.y=h.y):(s=(a-i)*b+i,pa.x=(h.x-j.x)*b+j.x,pa.y=(h.y-j.y)*b+j.y),f&&f(b),Ha(1===b)};c?db(\"customZoomTo\",0,1,c,d||e.easing.sine.inOut,k):k(1)}},fb=30,gb=10,hb={},ib={},jb={},kb={},lb={},mb=[],nb={},ob=[],pb={},qb=0,rb=ma(),sb=0,tb=ma(),ub=ma(),vb=ma(),wb=function(a,b){return a.x===b.x&&a.y===b.y},xb=function(a,b){return Math.abs(a.x-b.x)50){var d=ob.length>2?ob.shift():{};d.x=b,d.y=c,ob.push(d),Q=a}},Ib=function(){var a=pa.y-f.currItem.initialPosition.y;return 1-Math.abs(a/(qa.y/2))},Jb={},Kb={},Lb=[],Mb=function(a){for(;Lb.length>0;)Lb.pop();return F?(la=0,mb.forEach(function(a){0===la?Lb[0]=a:1===la&&(Lb[1]=a),la++})):a.type.indexOf(\"touch\")>-1?a.touches&&a.touches.length>0&&(Lb[0]=Fb(a.touches[0],Jb),a.touches.length>1&&(Lb[1]=Fb(a.touches[1],Kb))):(Jb.x=a.pageX,Jb.y=a.pageY,Jb.id=\"\",Lb[0]=Jb),Lb},Nb=function(a,b){var c,d,e,g,h=0,j=pa[a]+b[a],k=b[a]>0,l=tb.x+b.x,m=tb.x-nb.x;return c=j>da.min[a]||jda.min[a]&&(c=i.panEndFriction,h=da.min[a]-j,d=da.min[a]-oa[a]),(d0&&lf.currItem.fitRatio&&(pa[a]+=b[a]*c)):(void 0!==g&&(Ka(g,!0),$=g!==nb.x),da.min.x!==da.max.x&&(void 0!==e?pa.x=e:$||(pa.x+=b.x*c)),void 0!==g)},Ob=function(a){if(!(\"mousedown\"===a.type&&a.button>0)){if($b)return void a.preventDefault();if(!U||\"mousedown\"!==a.type){if(Eb(a,!0)&&a.preventDefault(),Da(\"pointerDown\"),F){var b=e.arraySearch(mb,a.pointerId,\"id\");b1&&!fa&&!$&&(t=s,X=!1,aa=W=!0,na.y=na.x=0,Ma(oa,pa),Ma(hb,c[0]),Ma(ib,c[1]),Gb(hb,ib,vb),ub.x=Math.abs(vb.x)-pa.x,ub.y=Math.abs(vb.y)-pa.y,ba=ca=yb(hb,ib))}}},Pb=function(a){if(a.preventDefault(),F){var b=e.arraySearch(mb,a.pointerId,\"id\");if(b>-1){var c=mb[b];c.x=a.pageX,c.y=a.pageY}}if(V){var d=Mb(a);if(ga||Y||aa)_=d;else if(tb.x!==ta.x*ra)ga=\"h\";else{var f=Math.abs(d[0].x-kb.x)-Math.abs(d[0].y-kb.y);Math.abs(f)>=gb&&(ga=f>0?\"h\":\"v\",_=d)}}},Qb=function(){if(_){var a=_.length;if(0!==a)if(Ma(hb,_[0]),jb.x=hb.x-kb.x,jb.y=hb.y-kb.y,aa&&a>1){if(kb.x=hb.x,kb.y=hb.y,!jb.x&&!jb.y&&wb(_[1],ib))return;Ma(ib,_[1]),X||(X=!0,Da(\"zoomGestureStarted\"));var b=yb(hb,ib),c=Vb(b);c>f.currItem.initialZoomLevel+f.currItem.initialZoomLevel/15&&(ka=!0);var d=1,e=Ta(),g=Ua();if(cg&&(d=(c-g)/(6*e),d>1&&(d=1),c=g+d*e);ds,s=c,Ha()}else{if(!ga)return;if(ha&&(ha=!1,Math.abs(jb.x)>=gb&&(jb.x-=_[0].x-lb.x),Math.abs(jb.y)>=gb&&(jb.y-=_[0].y-lb.y)),kb.x=hb.x,kb.y=hb.y,0===jb.x&&0===jb.y)return;if(\"v\"===ga&&i.closeOnVerticalDrag&&!Bb()){na.y+=jb.y,pa.y+=jb.y;var k=Ib();return T=!0,Da(\"onVerticalDrag\",k),Fa(k),void Ha()}Hb(Ea(),hb.x,hb.y),Y=!0,da=f.currItem.bounds;var l=Nb(\"x\",jb);l||(Nb(\"y\",jb),Na(pa),Ha())}}},Rb=function(a){if(N.isOldAndroid){if(U&&\"mouseup\"===a.type)return;a.type.indexOf(\"touch\")>-1&&(clearTimeout(U),U=setTimeout(function(){U=0},600))}Da(\"pointerUp\"),Eb(a,!1)&&a.preventDefault();var b;if(F){var c=e.arraySearch(mb,a.pointerId,\"id\");if(c>-1)if(b=mb.splice(c,1)[0],navigator.pointerEnabled)b.type=a.pointerType||\"mouse\";else{var d={4:\"mouse\",2:\"touch\",3:\"pen\"};b.type=d[a.pointerType],b.type||(b.type=a.pointerType||\"mouse\")}}var g,h=Mb(a),j=h.length;if(\"mouseup\"===a.type&&(j=0),2===j)return _=null,!0;1===j&&Ma(lb,h[0]),0!==j||ga||fa||(b||(\"mouseup\"===a.type?b={x:a.pageX,y:a.pageY,type:\"mouse\"}:a.changedTouches&&a.changedTouches[0]&&(b={x:a.changedTouches[0].pageX,y:a.changedTouches[0].pageY,type:\"touch\"})),Da(\"touchRelease\",a,b));var k=-1;if(0===j&&(V=!1,e.unbind(window,p,f),zb(),aa?k=0:sb!==-1&&(k=Ea()-sb)),sb=1===j?Ea():-1,g=k!==-1&&k1?(a=Ea()-Q+50,b=ob[ob.length-2][d]):(a=Ea()-P,b=lb[d]),c.lastFlickOffset[d]=kb[d]-b,c.lastFlickDist[d]=Math.abs(c.lastFlickOffset[d]),c.lastFlickDist[d]>20?c.lastFlickSpeed[d]=c.lastFlickOffset[d]/a:c.lastFlickSpeed[d]=0,Math.abs(c.lastFlickSpeed[d])da.min[a]?c.backAnimDestination[a]=da.min[a]:pa[a]fb&&(h||b.lastFlickOffset.x>20)?d=-1:gtb.x==b.lastFlickSpeed.x>0?(k=Math.abs(b.lastFlickSpeed.x)>0?n/Math.abs(b.lastFlickSpeed.x):333,k=Math.min(k,400),k=Math.max(k,250)):k=333,qb===m&&(c=!1),fa=!0,Da(\"mainScrollAnimStart\"),db(\"mainScroll\",tb.x,l,k,e.easing.cubic.out,Ka,function(){cb(),fa=!1,qb=-1,(c||qb!==m)&&f.updateCurrItem(),Da(\"mainScrollAnimComplete\")}),c&&f.updateCurrItem(!0),c},Vb=function(a){return 1/ca*a*t},Wb=function(){var a=s,b=Ta(),c=Ua();sc&&(a=c);var d,g=1,h=ja;return ia&&!S&&!ka&&s1||navigator.msMaxTouchPoints>1),f.likelyTouchDevice=G,r[A]=Ob,r[B]=Pb,r[C]=Rb,D&&(r[D]=r[C]),N.touch&&(q+=\" mousedown\",p+=\" mousemove mouseup\",r.mousedown=r[A],r.mousemove=r[B],r.mouseup=r[C]),G||(i.allowPanToNext=!1)}}});var Xb,Yb,Zb,$b,_b,ac,bc,cc=function(b,c,d,g){Xb&&clearTimeout(Xb),$b=!0,Zb=!0;var h;b.initialLayout?(h=b.initialLayout,b.initialLayout=null):h=i.getThumbBoundsFn&&i.getThumbBoundsFn(m);var j=d?i.hideAnimationDuration:i.showAnimationDuration,k=function(){ab(\"initialZoom\"),d?(f.template.removeAttribute(\"style\"),f.bg.removeAttribute(\"style\")):(Fa(1),c&&(c.style.display=\"block\"),e.addClass(a,\"pswp--animated-in\"),Da(\"initialZoom\"+(d?\"OutEnd\":\"InEnd\"))),g&&g(),$b=!1};if(!j||!h||void 0===h.x)return Da(\"initialZoom\"+(d?\"Out\":\"In\")),s=b.initialZoomLevel,Ma(pa,b.initialPosition),Ha(),a.style.opacity=d?0:1,Fa(1),void(j?setTimeout(function(){k()},j):k());var n=function(){var c=l,g=!f.currItem.src||f.currItem.loadError||i.showHideOpacity;b.miniImg&&(b.miniImg.style.webkitBackfaceVisibility=\"hidden\"),d||(s=h.w/b.w,pa.x=h.x,pa.y=h.y-K,f[g?\"template\":\"bg\"].style.opacity=.001,Ha()),bb(\"initialZoom\"),d&&!c&&e.removeClass(a,\"pswp--animated-in\"),g&&(d?e[(c?\"remove\":\"add\")+\"Class\"](a,\"pswp--animate_opacity\"):setTimeout(function(){e.addClass(a,\"pswp--animate_opacity\")},30)),Xb=setTimeout(function(){if(Da(\"initialZoom\"+(d?\"Out\":\"In\")),d){var f=h.w/b.w,i={x:pa.x,y:pa.y},l=s,m=ja,n=function(b){1===b?(s=f,pa.x=h.x,pa.y=h.y-M):(s=(f-l)*b+l,pa.x=(h.x-i.x)*b+i.x,pa.y=(h.y-M-i.y)*b+i.y),Ha(),g?a.style.opacity=1-b:Fa(m-b*m)};c?db(\"initialZoom\",0,1,j,e.easing.cubic.out,n,k):(n(1),Xb=setTimeout(k,j+20))}else s=b.initialZoomLevel,Ma(pa,b.initialPosition),Ha(),Fa(1),g?a.style.opacity=1:Fa(1),Xb=setTimeout(k,j+20)},d?25:90)};n()},dc={},ec=[],fc={index:0,errorMsg:'The image could not be loaded.',forceProgressiveLoading:!1,preload:[1,1],getNumItemsFn:function(){return Yb.length}},gc=function(){return{center:{x:0,y:0},max:{x:0,y:0},min:{x:0,y:0}}},hc=function(a,b,c){var d=a.bounds;d.center.x=Math.round((dc.x-b)/2),d.center.y=Math.round((dc.y-c)/2)+a.vGap.top,d.max.x=b>dc.x?Math.round(dc.x-b):d.center.x,d.max.y=c>dc.y?Math.round(dc.y-c)+a.vGap.top:d.center.y,d.min.x=b>dc.x?0:d.center.x,d.min.y=c>dc.y?a.vGap.top:d.center.y},ic=function(a,b,c){if(a.src&&!a.loadError){var d=!c;if(d&&(a.vGap||(a.vGap={top:0,bottom:0}),Da(\"parseVerticalMargin\",a)),dc.x=b.x,dc.y=b.y-a.vGap.top-a.vGap.bottom,d){var e=dc.x/a.w,f=dc.y/a.h;a.fitRatio=e1&&(c=1),a.initialZoomLevel=c,a.bounds||(a.bounds=gc())}if(!c)return;return hc(a,a.w*c,a.h*c),d&&c===a.initialZoomLevel&&(a.initialPosition=a.bounds.center),a.bounds}return a.w=a.h=0,a.initialZoomLevel=a.fitRatio=1,a.bounds=gc(),a.initialPosition=a.bounds.center,a.bounds},jc=function(a,b,c,d,e,g){b.loadError||d&&(b.imageAppended=!0,mc(b,d,b===f.currItem&&ya),c.appendChild(d),g&&setTimeout(function(){b&&b.loaded&&b.placeholder&&(b.placeholder.style.display=\"none\",b.placeholder=null)},500))},kc=function(a){a.loading=!0,a.loaded=!1;var b=a.img=e.createEl(\"pswp__img\",\"img\"),c=function(){a.loading=!1,a.loaded=!0,a.loadComplete?a.loadComplete(a):a.img=null,b.onload=b.onerror=null,b=null};return b.onload=c,b.onerror=function(){a.loadError=!0,c()},b.src=a.src,b},lc=function(a,b){if(a.src&&a.loadError&&a.container)return b&&(a.container.innerHTML=\"\"),a.container.innerHTML=i.errorMsg.replace(\"%url%\",a.src),!0},mc=function(a,b,c){if(a.src){b||(b=a.container.lastChild);var d=c?a.w:Math.round(a.w*a.fitRatio),e=c?a.h:Math.round(a.h*a.fitRatio);a.placeholder&&!a.loaded&&(a.placeholder.style.width=d+\"px\",a.placeholder.style.height=e+\"px\"),b.style.width=d+\"px\",b.style.height=e+\"px\"}},nc=function(){if(ec.length){for(var a,b=0;b=0,e=Math.min(c[0],ac()),g=Math.min(c[1],ac());for(b=1;b1200},setContent:function(a,b){i.loop&&(b=Aa(b));var c=f.getItemAt(a.index);c&&(c.container=null);var d,g=f.getItemAt(b);if(!g)return void(a.el.innerHTML=\"\");Da(\"gettingData\",b,g),a.index=b,a.item=g;var h=g.container=e.createEl(\"pswp__zoom-wrap\");if(!g.src&&g.html&&(g.html.tagName?h.appendChild(g.html):h.innerHTML=g.html),lc(g),ic(g,qa),!g.src||g.loadError||g.loaded)g.src&&!g.loadError&&(d=e.createEl(\"pswp__img\",\"img\"),d.style.opacity=1,d.src=g.src,mc(g,d),jc(b,g,h,d,!0));else{if(g.loadComplete=function(c){if(j){if(a&&a.index===b){if(lc(c,!0))return c.loadComplete=c.img=null,ic(c,qa),Ia(c),void(a.index===m&&f.updateCurrZoomItem());c.imageAppended?!$b&&c.placeholder&&(c.placeholder.style.display=\"none\",c.placeholder=null):N.transform&&(fa||$b)?ec.push({item:c,baseDiv:h,img:c.img,index:b,holder:a,clearPlaceholder:!0}):jc(b,c,h,c.img,fa||$b,!0)}c.loadComplete=null,c.img=null,Da(\"imageLoadComplete\",b,c)}},e.features.transform){var k=\"pswp__img pswp__img--placeholder\";k+=g.msrc?\"\":\" pswp__img--placeholder--blank\";var l=e.createEl(k,g.msrc?\"img\":\"\");g.msrc&&(l.src=g.msrc),mc(g,l),h.appendChild(l),g.placeholder=l}g.loading||kc(g),f.allowProgressiveImg()&&(!Zb&&N.transform?ec.push({item:g,baseDiv:h,img:g.img,index:b,holder:a}):jc(b,g,h,g.img,!0,!0))}Zb||b!==m?Ia(g):(ea=h.style,cc(g,d||g.img)),a.el.innerHTML=\"\",a.el.appendChild(h)},cleanSlide:function(a){a.img&&(a.img.onload=a.img.onerror=null),a.loaded=a.loading=a.img=a.imageAppended=!1}}});var oc,pc={},qc=function(a,b,c){var d=document.createEvent(\"CustomEvent\"),e={origEvent:a,target:a.target,releasePoint:b,pointerType:c||\"touch\"};d.initCustomEvent(\"pswpTap\",!0,!0,e),a.target.dispatchEvent(d)};za(\"Tap\",{publicMethods:{initTap:function(){Ca(\"firstTouchStart\",f.onTapStart),Ca(\"touchRelease\",f.onTapRelease),Ca(\"destroy\",function(){pc={},oc=null})},onTapStart:function(a){a.length>1&&(clearTimeout(oc),oc=null)},onTapRelease:function(a,b){if(b&&!Y&&!W&&!_a){var c=b;if(oc&&(clearTimeout(oc),oc=null,xb(c,pc)))return void Da(\"doubleTap\",c);if(\"mouse\"===b.type)return void qc(a,b,\"mouse\");var d=a.target.tagName.toUpperCase();if(\"BUTTON\"===d||e.hasClass(a.target,\"pswp__single-tap\"))return void qc(a,b);Ma(pc,c),oc=setTimeout(function(){qc(a,b),oc=null},300)}}}});var rc;za(\"DesktopZoom\",{publicMethods:{initDesktopZoom:function(){L||(G?Ca(\"mouseUsed\",function(){f.setupDesktopZoom()}):f.setupDesktopZoom(!0))},setupDesktopZoom:function(b){rc={};var c=\"wheel mousewheel DOMMouseScroll\";Ca(\"bindEvents\",function(){e.bind(a,c,f.handleMouseWheel)}),Ca(\"unbindEvents\",function(){rc&&e.unbind(a,c,f.handleMouseWheel)}),f.mouseZoomedIn=!1;var d,g=function(){f.mouseZoomedIn&&(e.removeClass(a,\"pswp--zoomed-in\"),f.mouseZoomedIn=!1),s"},{"title":"","date":"2019-07-02T09:53:53.731Z","updated":"2019-07-02T08:52:41.201Z","comments":true,"path":"lib/photoswipe/photoswipe.js","permalink":"https://137942170.github.io/fwtBlog/lib/photoswipe/photoswipe.js","excerpt":"","text":"/*! PhotoSwipe - v4.1.2 - 2017-04-05 * http://photoswipe.com * Copyright (c) 2017 Dmitry Semenov; */ (function (root, factory) { if (typeof define === 'function' && define.amd) { define(factory); } else if (typeof exports === 'object') { module.exports = factory(); } else { root.PhotoSwipe = factory(); } })(this, function () { 'use strict'; var PhotoSwipe = function(template, UiClass, items, options){ /*>>framework-bridge*/ /** * * Set of generic functions used by gallery. * * You're free to modify anything here as long as functionality is kept. * */ var framework = { features: null, bind: function(target, type, listener, unbind) { var methodName = (unbind ? 'remove' : 'add') + 'EventListener'; type = type.split(' '); for(var i = 0; i < type.length; i++) { if(type[i]) { target[methodName]( type[i], listener, false); } } }, isArray: function(obj) { return (obj instanceof Array); }, createEl: function(classes, tag) { var el = document.createElement(tag || 'div'); if(classes) { el.className = classes; } return el; }, getScrollY: function() { var yOffset = window.pageYOffset; return yOffset !== undefined ? yOffset : document.documentElement.scrollTop; }, unbind: function(target, type, listener) { framework.bind(target,type,listener,true); }, removeClass: function(el, className) { var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'); el.className = el.className.replace(reg, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); }, addClass: function(el, className) { if( !framework.hasClass(el,className) ) { el.className += (el.className ? ' ' : '') + className; } }, hasClass: function(el, className) { return el.className && new RegExp('(^|\\\\s)' + className + '(\\\\s|$)').test(el.className); }, getChildByClass: function(parentEl, childClassName) { var node = parentEl.firstChild; while(node) { if( framework.hasClass(node, childClassName) ) { return node; } node = node.nextSibling; } }, arraySearch: function(array, value, key) { var i = array.length; while(i--) { if(array[i][key] === value) { return i; } } return -1; }, extend: function(o1, o2, preventOverwrite) { for (var prop in o2) { if (o2.hasOwnProperty(prop)) { if(preventOverwrite && o1.hasOwnProperty(prop)) { continue; } o1[prop] = o2[prop]; } } }, easing: { sine: { out: function(k) { return Math.sin(k * (Math.PI / 2)); }, inOut: function(k) { return - (Math.cos(Math.PI * k) - 1) / 2; } }, cubic: { out: function(k) { return --k * k * k + 1; } } /* elastic: { out: function ( k ) { var s, a = 0.1, p = 0.4; if ( k === 0 ) return 0; if ( k === 1 ) return 1; if ( !a || a < 1 ) { a = 1; s = p / 4; } else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI ); return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 ); }, }, back: { out: function ( k ) { var s = 1.70158; return --k * k * ( ( s + 1 ) * k + s ) + 1; } } */ }, /** * * @return {object} * * { * raf : request animation frame function * caf : cancel animation frame function * transfrom : transform property key (with vendor), or null if not supported * oldIE : IE8 or below * } * */ detectFeatures: function() { if(framework.features) { return framework.features; } var helperEl = framework.createEl(), helperStyle = helperEl.style, vendor = '', features = {}; // IE8 and below features.oldIE = document.all && !document.addEventListener; features.touch = 'ontouchstart' in window; if(window.requestAnimationFrame) { features.raf = window.requestAnimationFrame; features.caf = window.cancelAnimationFrame; } features.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled; // fix false-positive detection of old Android in new IE // (IE11 ua string contains \"Android 4.0\") if(!features.pointerEvent) { var ua = navigator.userAgent; // Detect if device is iPhone or iPod and if it's older than iOS 8 // http://stackoverflow.com/a/14223920 // // This detection is made because of buggy top/bottom toolbars // that don't trigger window.resize event. // For more info refer to _isFixedPosition variable in core.js if (/iP(hone|od)/.test(navigator.platform)) { var v = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/); if(v && v.length > 0) { v = parseInt(v[1], 10); if(v >= 1 && v < 8 ) { features.isOldIOSPhone = true; } } } // Detect old Android (before KitKat) // due to bugs related to position:fixed // http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript var match = ua.match(/Android\\s([0-9\\.]*)/); var androidversion = match ? match[1] : 0; androidversion = parseFloat(androidversion); if(androidversion >= 1 ) { if(androidversion < 4.4) { features.isOldAndroid = true; // for fixed position bug & performance } features.androidVersion = androidversion; // for touchend bug } features.isMobileOpera = /opera mini|opera mobi/i.test(ua); // p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs. } var styleChecks = ['transform', 'perspective', 'animationName'], vendors = ['', 'webkit','Moz','ms','O'], styleCheckItem, styleName; for(var i = 0; i < 4; i++) { vendor = vendors[i]; for(var a = 0; a < 3; a++) { styleCheckItem = styleChecks[a]; // uppercase first letter of property name, if vendor is present styleName = vendor + (vendor ? styleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) : styleCheckItem); if(!features[styleCheckItem] && styleName in helperStyle ) { features[styleCheckItem] = styleName; } } if(vendor && !features.raf) { vendor = vendor.toLowerCase(); features.raf = window[vendor+'RequestAnimationFrame']; if(features.raf) { features.caf = window[vendor+'CancelAnimationFrame'] || window[vendor+'CancelRequestAnimationFrame']; } } } if(!features.raf) { var lastTime = 0; features.raf = function(fn) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() { fn(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; features.caf = function(id) { clearTimeout(id); }; } // Detect SVG support features.svg = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect; framework.features = features; return features; } }; framework.detectFeatures(); // Override addEventListener for old versions of IE if(framework.features.oldIE) { framework.bind = function(target, type, listener, unbind) { type = type.split(' '); var methodName = (unbind ? 'detach' : 'attach') + 'Event', evName, _handleEv = function() { listener.handleEvent.call(listener); }; for(var i = 0; i < type.length; i++) { evName = type[i]; if(evName) { if(typeof listener === 'object' && listener.handleEvent) { if(!unbind) { listener['oldIE' + evName] = _handleEv; } else { if(!listener['oldIE' + evName]) { return false; } } target[methodName]( 'on' + evName, listener['oldIE' + evName]); } else { target[methodName]( 'on' + evName, listener); } } } }; } /*>>framework-bridge*/ /*>>core*/ //function(template, UiClass, items, options) var self = this; /** * Static vars, don't change unless you know what you're doing. */ var DOUBLE_TAP_RADIUS = 25, NUM_HOLDERS = 3; /** * Options */ var _options = { allowPanToNext:true, spacing: 0.12, bgOpacity: 1, mouseUsed: false, loop: true, pinchToClose: true, closeOnScroll: true, closeOnVerticalDrag: true, verticalDragRange: 0.75, hideAnimationDuration: 333, showAnimationDuration: 333, showHideOpacity: false, focus: true, escKey: true, arrowKeys: true, mainScrollEndFriction: 0.35, panEndFriction: 0.35, isClickableElement: function(el) { return el.tagName === 'A'; }, getDoubleTapZoom: function(isMouseClick, item) { if(isMouseClick) { return 1; } else { return item.initialZoomLevel < 0.7 ? 1 : 1.33; } }, maxSpreadZoom: 1.33, modal: true, // not fully implemented yet scaleMode: 'fit' // TODO }; framework.extend(_options, options); /** * Private helper variables & functions */ var _getEmptyPoint = function() { return {x:0,y:0}; }; var _isOpen, _isDestroying, _closedByScroll, _currentItemIndex, _containerStyle, _containerShiftIndex, _currPanDist = _getEmptyPoint(), _startPanOffset = _getEmptyPoint(), _panOffset = _getEmptyPoint(), _upMoveEvents, // drag move, drag end & drag cancel events array _downEvents, // drag start events array _globalEventHandlers, _viewportSize = {}, _currZoomLevel, _startZoomLevel, _translatePrefix, _translateSufix, _updateSizeInterval, _itemsNeedUpdate, _currPositionIndex = 0, _offset = {}, _slideSize = _getEmptyPoint(), // size of slide area, including spacing _itemHolders, _prevItemIndex, _indexDiff = 0, // difference of indexes since last content update _dragStartEvent, _dragMoveEvent, _dragEndEvent, _dragCancelEvent, _transformKey, _pointerEventEnabled, _isFixedPosition = true, _likelyTouchDevice, _modules = [], _requestAF, _cancelAF, _initalClassName, _initalWindowScrollY, _oldIE, _currentWindowScrollY, _features, _windowVisibleSize = {}, _renderMaxResolution = false, _orientationChangeTimeout, // Registers PhotoSWipe module (History, Controller ...) _registerModule = function(name, module) { framework.extend(self, module.publicMethods); _modules.push(name); }, _getLoopedId = function(index) { var numSlides = _getNumItems(); if(index > numSlides - 1) { return index - numSlides; } else if(index < 0) { return numSlides + index; } return index; }, // Micro bind/trigger _listeners = {}, _listen = function(name, fn) { if(!_listeners[name]) { _listeners[name] = []; } return _listeners[name].push(fn); }, _shout = function(name) { var listeners = _listeners[name]; if(listeners) { var args = Array.prototype.slice.call(arguments); args.shift(); for(var i = 0; i < listeners.length; i++) { listeners[i].apply(self, args); } } }, _getCurrentTime = function() { return new Date().getTime(); }, _applyBgOpacity = function(opacity) { _bgOpacity = opacity; self.bg.style.opacity = opacity * _options.bgOpacity; }, _applyZoomTransform = function(styleObj,x,y,zoom,item) { if(!_renderMaxResolution || (item && item !== self.currItem) ) { zoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio); } styleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')'; }, _applyCurrentZoomPan = function( allowRenderResolution ) { if(_currZoomElementStyle) { if(allowRenderResolution) { if(_currZoomLevel > self.currItem.fitRatio) { if(!_renderMaxResolution) { _setImageSize(self.currItem, false, true); _renderMaxResolution = true; } } else { if(_renderMaxResolution) { _setImageSize(self.currItem); _renderMaxResolution = false; } } } _applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel); } }, _applyZoomPanToItem = function(item) { if(item.container) { _applyZoomTransform(item.container.style, item.initialPosition.x, item.initialPosition.y, item.initialZoomLevel, item); } }, _setTranslateX = function(x, elStyle) { elStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix; }, _moveMainScroll = function(x, dragging) { if(!_options.loop && dragging) { var newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x, delta = Math.round(x - _mainScrollPos.x); if( (newSlideIndexOffset < 0 && delta > 0) || (newSlideIndexOffset >= _getNumItems() - 1 && delta < 0) ) { x = _mainScrollPos.x + delta * _options.mainScrollEndFriction; } } _mainScrollPos.x = x; _setTranslateX(x, _containerStyle); }, _calculatePanOffset = function(axis, zoomLevel) { var m = _midZoomPoint[axis] - _offset[axis]; return _startPanOffset[axis] + _currPanDist[axis] + m - m * ( zoomLevel / _startZoomLevel ); }, _equalizePoints = function(p1, p2) { p1.x = p2.x; p1.y = p2.y; if(p2.id) { p1.id = p2.id; } }, _roundPoint = function(p) { p.x = Math.round(p.x); p.y = Math.round(p.y); }, _mouseMoveTimeout = null, _onFirstMouseMove = function() { // Wait until mouse move event is fired at least twice during 100ms // We do this, because some mobile browsers trigger it on touchstart if(_mouseMoveTimeout ) { framework.unbind(document, 'mousemove', _onFirstMouseMove); framework.addClass(template, 'pswp--has_mouse'); _options.mouseUsed = true; _shout('mouseUsed'); } _mouseMoveTimeout = setTimeout(function() { _mouseMoveTimeout = null; }, 100); }, _bindEvents = function() { framework.bind(document, 'keydown', self); if(_features.transform) { // don't bind click event in browsers that don't support transform (mostly IE8) framework.bind(self.scrollWrap, 'click', self); } if(!_options.mouseUsed) { framework.bind(document, 'mousemove', _onFirstMouseMove); } framework.bind(window, 'resize scroll orientationchange', self); _shout('bindEvents'); }, _unbindEvents = function() { framework.unbind(window, 'resize scroll orientationchange', self); framework.unbind(window, 'scroll', _globalEventHandlers.scroll); framework.unbind(document, 'keydown', self); framework.unbind(document, 'mousemove', _onFirstMouseMove); if(_features.transform) { framework.unbind(self.scrollWrap, 'click', self); } if(_isDragging) { framework.unbind(window, _upMoveEvents, self); } clearTimeout(_orientationChangeTimeout); _shout('unbindEvents'); }, _calculatePanBounds = function(zoomLevel, update) { var bounds = _calculateItemSize( self.currItem, _viewportSize, zoomLevel ); if(update) { _currPanBounds = bounds; } return bounds; }, _getMinZoomLevel = function(item) { if(!item) { item = self.currItem; } return item.initialZoomLevel; }, _getMaxZoomLevel = function(item) { if(!item) { item = self.currItem; } return item.w > 0 ? _options.maxSpreadZoom : 1; }, // Return true if offset is out of the bounds _modifyDestPanOffset = function(axis, destPanBounds, destPanOffset, destZoomLevel) { if(destZoomLevel === self.currItem.initialZoomLevel) { destPanOffset[axis] = self.currItem.initialPosition[axis]; return true; } else { destPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel); if(destPanOffset[axis] > destPanBounds.min[axis]) { destPanOffset[axis] = destPanBounds.min[axis]; return true; } else if(destPanOffset[axis] < destPanBounds.max[axis] ) { destPanOffset[axis] = destPanBounds.max[axis]; return true; } } return false; }, _setupTransforms = function() { if(_transformKey) { // setup 3d transforms var allow3dTransform = _features.perspective && !_likelyTouchDevice; _translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '('); _translateSufix = _features.perspective ? ', 0px)' : ')'; return; } // Override zoom/pan/move functions in case old browser is used (most likely IE) // (so they use left/top/width/height, instead of CSS transform) _transformKey = 'left'; framework.addClass(template, 'pswp--ie'); _setTranslateX = function(x, elStyle) { elStyle.left = x + 'px'; }; _applyZoomPanToItem = function(item) { var zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio, s = item.container.style, w = zoomRatio * item.w, h = zoomRatio * item.h; s.width = w + 'px'; s.height = h + 'px'; s.left = item.initialPosition.x + 'px'; s.top = item.initialPosition.y + 'px'; }; _applyCurrentZoomPan = function() { if(_currZoomElementStyle) { var s = _currZoomElementStyle, item = self.currItem, zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio, w = zoomRatio * item.w, h = zoomRatio * item.h; s.width = w + 'px'; s.height = h + 'px'; s.left = _panOffset.x + 'px'; s.top = _panOffset.y + 'px'; } }; }, _onKeyDown = function(e) { var keydownAction = ''; if(_options.escKey && e.keyCode === 27) { keydownAction = 'close'; } else if(_options.arrowKeys) { if(e.keyCode === 37) { keydownAction = 'prev'; } else if(e.keyCode === 39) { keydownAction = 'next'; } } if(keydownAction) { // don't do anything if special key pressed to prevent from overriding default browser actions // e.g. in Chrome on Mac cmd+arrow-left returns to previous page if( !e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey ) { if(e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; } self[keydownAction](); } } }, _onGlobalClick = function(e) { if(!e) { return; } // don't allow click event to pass through when triggering after drag or some other gesture if(_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) { e.preventDefault(); e.stopPropagation(); } }, _updatePageScrollOffset = function() { self.setScrollOffset(0, framework.getScrollY()); }; // Micro animation engine var _animations = {}, _numAnimations = 0, _stopAnimation = function(name) { if(_animations[name]) { if(_animations[name].raf) { _cancelAF( _animations[name].raf ); } _numAnimations--; delete _animations[name]; } }, _registerStartAnimation = function(name) { if(_animations[name]) { _stopAnimation(name); } if(!_animations[name]) { _numAnimations++; _animations[name] = {}; } }, _stopAllAnimations = function() { for (var prop in _animations) { if( _animations.hasOwnProperty( prop ) ) { _stopAnimation(prop); } } }, _animateProp = function(name, b, endProp, d, easingFn, onUpdate, onComplete) { var startAnimTime = _getCurrentTime(), t; _registerStartAnimation(name); var animloop = function(){ if ( _animations[name] ) { t = _getCurrentTime() - startAnimTime; // time diff //b - beginning (start prop) //d - anim duration if ( t >= d ) { _stopAnimation(name); onUpdate(endProp); if(onComplete) { onComplete(); } return; } onUpdate( (endProp - b) * easingFn(t/d) + b ); _animations[name].raf = _requestAF(animloop); } }; animloop(); }; var publicMethods = { // make a few local variables and functions public shout: _shout, listen: _listen, viewportSize: _viewportSize, options: _options, isMainScrollAnimating: function() { return _mainScrollAnimating; }, getZoomLevel: function() { return _currZoomLevel; }, getCurrentIndex: function() { return _currentItemIndex; }, isDragging: function() { return _isDragging; }, isZooming: function() { return _isZooming; }, setScrollOffset: function(x,y) { _offset.x = x; _currentWindowScrollY = _offset.y = y; _shout('updateScrollOffset', _offset); }, applyZoomPan: function(zoomLevel,panX,panY,allowRenderResolution) { _panOffset.x = panX; _panOffset.y = panY; _currZoomLevel = zoomLevel; _applyCurrentZoomPan( allowRenderResolution ); }, init: function() { if(_isOpen || _isDestroying) { return; } var i; self.framework = framework; // basic functionality self.template = template; // root DOM element of PhotoSwipe self.bg = framework.getChildByClass(template, 'pswp__bg'); _initalClassName = template.className; _isOpen = true; _features = framework.detectFeatures(); _requestAF = _features.raf; _cancelAF = _features.caf; _transformKey = _features.transform; _oldIE = _features.oldIE; self.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap'); self.container = framework.getChildByClass(self.scrollWrap, 'pswp__container'); _containerStyle = self.container.style; // for fast access // Objects that hold slides (there are only 3 in DOM) self.itemHolders = _itemHolders = [ {el:self.container.children[0] , wrap:0, index: -1}, {el:self.container.children[1] , wrap:0, index: -1}, {el:self.container.children[2] , wrap:0, index: -1} ]; // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints) _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none'; _setupTransforms(); // Setup global events _globalEventHandlers = { resize: self.updateSize, // Fixes: iOS 10.3 resize event // does not update scrollWrap.clientWidth instantly after resize // https://github.com/dimsemenov/PhotoSwipe/issues/1315 orientationchange: function() { clearTimeout(_orientationChangeTimeout); _orientationChangeTimeout = setTimeout(function() { if(_viewportSize.x !== self.scrollWrap.clientWidth) { self.updateSize(); } }, 500); }, scroll: _updatePageScrollOffset, keydown: _onKeyDown, click: _onGlobalClick }; // disable show/hide effects on old browsers that don't support CSS animations or transforms, // old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models. var oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera; if(!_features.animationName || !_features.transform || oldPhone) { _options.showAnimationDuration = _options.hideAnimationDuration = 0; } // init modules for(i = 0; i < _modules.length; i++) { self['init' + _modules[i]](); } // init if(UiClass) { var ui = self.ui = new UiClass(self, framework); ui.init(); } _shout('firstUpdate'); _currentItemIndex = _currentItemIndex || _options.index || 0; // validate index if( isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems() ) { _currentItemIndex = 0; } self.currItem = _getItemAt( _currentItemIndex ); if(_features.isOldIOSPhone || _features.isOldAndroid) { _isFixedPosition = false; } template.setAttribute('aria-hidden', 'false'); if(_options.modal) { if(!_isFixedPosition) { template.style.position = 'absolute'; template.style.top = framework.getScrollY() + 'px'; } else { template.style.position = 'fixed'; } } if(_currentWindowScrollY === undefined) { _shout('initialLayout'); _currentWindowScrollY = _initalWindowScrollY = framework.getScrollY(); } // add classes to root element of PhotoSwipe var rootClasses = 'pswp--open '; if(_options.mainClass) { rootClasses += _options.mainClass + ' '; } if(_options.showHideOpacity) { rootClasses += 'pswp--animate_opacity '; } rootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch'; rootClasses += _features.animationName ? ' pswp--css_animation' : ''; rootClasses += _features.svg ? ' pswp--svg' : ''; framework.addClass(template, rootClasses); self.updateSize(); // initial update _containerShiftIndex = -1; _indexDiff = null; for(i = 0; i < NUM_HOLDERS; i++) { _setTranslateX( (i+_containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style); } if(!_oldIE) { framework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE } _listen('initialZoomInEnd', function() { self.setContent(_itemHolders[0], _currentItemIndex-1); self.setContent(_itemHolders[2], _currentItemIndex+1); _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block'; if(_options.focus) { // focus causes layout, // which causes lag during the animation, // that's why we delay it untill the initial zoom transition ends template.focus(); } _bindEvents(); }); // set content for center slide (first time) self.setContent(_itemHolders[1], _currentItemIndex); self.updateCurrItem(); _shout('afterInit'); if(!_isFixedPosition) { // On all versions of iOS lower than 8.0, we check size of viewport every second. // // This is done to detect when Safari top & bottom bars appear, // as this action doesn't trigger any events (like resize). // // On iOS8 they fixed this. // // 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%. _updateSizeInterval = setInterval(function() { if(!_numAnimations && !_isDragging && !_isZooming && (_currZoomLevel === self.currItem.initialZoomLevel) ) { self.updateSize(); } }, 1000); } framework.addClass(template, 'pswp--visible'); }, // Close the gallery, then destroy it close: function() { if(!_isOpen) { return; } _isOpen = false; _isDestroying = true; _shout('close'); _unbindEvents(); _showOrHide(self.currItem, null, true, self.destroy); }, // destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks) destroy: function() { _shout('destroy'); if(_showOrHideTimeout) { clearTimeout(_showOrHideTimeout); } template.setAttribute('aria-hidden', 'true'); template.className = _initalClassName; if(_updateSizeInterval) { clearInterval(_updateSizeInterval); } framework.unbind(self.scrollWrap, _downEvents, self); // we unbind scroll event at the end, as closing animation may depend on it framework.unbind(window, 'scroll', self); _stopDragUpdateLoop(); _stopAllAnimations(); _listeners = null; }, /** * Pan image to position * @param {Number} x * @param {Number} y * @param {Boolean} force Will ignore bounds if set to true. */ panTo: function(x,y,force) { if(!force) { if(x > _currPanBounds.min.x) { x = _currPanBounds.min.x; } else if(x < _currPanBounds.max.x) { x = _currPanBounds.max.x; } if(y > _currPanBounds.min.y) { y = _currPanBounds.min.y; } else if(y < _currPanBounds.max.y) { y = _currPanBounds.max.y; } } _panOffset.x = x; _panOffset.y = y; _applyCurrentZoomPan(); }, handleEvent: function (e) { e = e || window.event; if(_globalEventHandlers[e.type]) { _globalEventHandlers[e.type](e); } }, goTo: function(index) { index = _getLoopedId(index); var diff = index - _currentItemIndex; _indexDiff = diff; _currentItemIndex = index; self.currItem = _getItemAt( _currentItemIndex ); _currPositionIndex -= diff; _moveMainScroll(_slideSize.x * _currPositionIndex); _stopAllAnimations(); _mainScrollAnimating = false; self.updateCurrItem(); }, next: function() { self.goTo( _currentItemIndex + 1); }, prev: function() { self.goTo( _currentItemIndex - 1); }, // update current zoom/pan objects updateCurrZoomItem: function(emulateSetContent) { if(emulateSetContent) { _shout('beforeChange', 0); } // itemHolder[1] is middle (current) item if(_itemHolders[1].el.children.length) { var zoomElement = _itemHolders[1].el.children[0]; if( framework.hasClass(zoomElement, 'pswp__zoom-wrap') ) { _currZoomElementStyle = zoomElement.style; } else { _currZoomElementStyle = null; } } else { _currZoomElementStyle = null; } _currPanBounds = self.currItem.bounds; _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel; _panOffset.x = _currPanBounds.center.x; _panOffset.y = _currPanBounds.center.y; if(emulateSetContent) { _shout('afterChange'); } }, invalidateCurrItems: function() { _itemsNeedUpdate = true; for(var i = 0; i < NUM_HOLDERS; i++) { if( _itemHolders[i].item ) { _itemHolders[i].item.needsUpdate = true; } } }, updateCurrItem: function(beforeAnimation) { if(_indexDiff === 0) { return; } var diffAbs = Math.abs(_indexDiff), tempHolder; if(beforeAnimation && diffAbs < 2) { return; } self.currItem = _getItemAt( _currentItemIndex ); _renderMaxResolution = false; _shout('beforeChange', _indexDiff); if(diffAbs >= NUM_HOLDERS) { _containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS); diffAbs = NUM_HOLDERS; } for(var i = 0; i < diffAbs; i++) { if(_indexDiff > 0) { tempHolder = _itemHolders.shift(); _itemHolders[NUM_HOLDERS-1] = tempHolder; // move first to last _containerShiftIndex++; _setTranslateX( (_containerShiftIndex+2) * _slideSize.x, tempHolder.el.style); self.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1); } else { tempHolder = _itemHolders.pop(); _itemHolders.unshift( tempHolder ); // move last to first _containerShiftIndex--; _setTranslateX( _containerShiftIndex * _slideSize.x, tempHolder.el.style); self.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1); } } // reset zoom/pan on previous item if(_currZoomElementStyle && Math.abs(_indexDiff) === 1) { var prevItem = _getItemAt(_prevItemIndex); if(prevItem.initialZoomLevel !== _currZoomLevel) { _calculateItemSize(prevItem , _viewportSize ); _setImageSize(prevItem); _applyZoomPanToItem( prevItem ); } } // reset diff after update _indexDiff = 0; self.updateCurrZoomItem(); _prevItemIndex = _currentItemIndex; _shout('afterChange'); }, updateSize: function(force) { if(!_isFixedPosition && _options.modal) { var windowScrollY = framework.getScrollY(); if(_currentWindowScrollY !== windowScrollY) { template.style.top = windowScrollY + 'px'; _currentWindowScrollY = windowScrollY; } if(!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) { return; } _windowVisibleSize.x = window.innerWidth; _windowVisibleSize.y = window.innerHeight; //template.style.width = _windowVisibleSize.x + 'px'; template.style.height = _windowVisibleSize.y + 'px'; } _viewportSize.x = self.scrollWrap.clientWidth; _viewportSize.y = self.scrollWrap.clientHeight; _updatePageScrollOffset(); _slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing); _slideSize.y = _viewportSize.y; _moveMainScroll(_slideSize.x * _currPositionIndex); _shout('beforeResize'); // even may be used for example to switch image sources // don't re-calculate size on inital size update if(_containerShiftIndex !== undefined) { var holder, item, hIndex; for(var i = 0; i < NUM_HOLDERS; i++) { holder = _itemHolders[i]; _setTranslateX( (i+_containerShiftIndex) * _slideSize.x, holder.el.style); hIndex = _currentItemIndex+i-1; if(_options.loop && _getNumItems() > 2) { hIndex = _getLoopedId(hIndex); } // update zoom level on items and refresh source (if needsUpdate) item = _getItemAt( hIndex ); // re-render gallery item if `needsUpdate`, // or doesn't have `bounds` (entirely new slide object) if( item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds) ) { self.cleanSlide( item ); self.setContent( holder, hIndex ); // if \"center\" slide if(i === 1) { self.currItem = item; self.updateCurrZoomItem(true); } item.needsUpdate = false; } else if(holder.index === -1 && hIndex >= 0) { // add content first time self.setContent( holder, hIndex ); } if(item && item.container) { _calculateItemSize(item, _viewportSize); _setImageSize(item); _applyZoomPanToItem( item ); } } _itemsNeedUpdate = false; } _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel; _currPanBounds = self.currItem.bounds; if(_currPanBounds) { _panOffset.x = _currPanBounds.center.x; _panOffset.y = _currPanBounds.center.y; _applyCurrentZoomPan( true ); } _shout('resize'); }, // Zoom current item to zoomTo: function(destZoomLevel, centerPoint, speed, easingFn, updateFn) { /* if(destZoomLevel === 'fit') { destZoomLevel = self.currItem.fitRatio; } else if(destZoomLevel === 'fill') { destZoomLevel = self.currItem.fillRatio; } */ if(centerPoint) { _startZoomLevel = _currZoomLevel; _midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x ; _midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y ; _equalizePoints(_startPanOffset, _panOffset); } var destPanBounds = _calculatePanBounds(destZoomLevel, false), destPanOffset = {}; _modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel); _modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel); var initialZoomLevel = _currZoomLevel; var initialPanOffset = { x: _panOffset.x, y: _panOffset.y }; _roundPoint(destPanOffset); var onUpdate = function(now) { if(now === 1) { _currZoomLevel = destZoomLevel; _panOffset.x = destPanOffset.x; _panOffset.y = destPanOffset.y; } else { _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel; _panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x; _panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y; } if(updateFn) { updateFn(now); } _applyCurrentZoomPan( now === 1 ); }; if(speed) { _animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate); } else { onUpdate(1); } } }; /*>>core*/ /*>>gestures*/ /** * Mouse/touch/pointer event handlers. * * separated from @core.js for readability */ var MIN_SWIPE_DISTANCE = 30, DIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe var _gestureStartTime, _gestureCheckSpeedTime, // pool of objects that are used during dragging of zooming p = {}, // first point p2 = {}, // second point (for zoom gesture) delta = {}, _currPoint = {}, _startPoint = {}, _currPointers = [], _startMainScrollPos = {}, _releaseAnimData, _posPoints = [], // array of points during dragging, used to determine type of gesture _tempPoint = {}, _isZoomingIn, _verticalDragInitiated, _oldAndroidTouchEndTimeout, _currZoomedItemIndex = 0, _centerPoint = _getEmptyPoint(), _lastReleaseTime = 0, _isDragging, // at least one pointer is down _isMultitouch, // at least two _pointers are down _zoomStarted, // zoom level changed during zoom gesture _moved, _dragAnimFrame, _mainScrollShifted, _currentPoints, // array of current touch points _isZooming, _currPointsDistance, _startPointsDistance, _currPanBounds, _mainScrollPos = _getEmptyPoint(), _currZoomElementStyle, _mainScrollAnimating, // true, if animation after swipe gesture is running _midZoomPoint = _getEmptyPoint(), _currCenterPoint = _getEmptyPoint(), _direction, _isFirstMove, _opacityChanged, _bgOpacity, _wasOverInitialZoom, _isEqualPoints = function(p1, p2) { return p1.x === p2.x && p1.y === p2.y; }, _isNearbyPoints = function(touch0, touch1) { return Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS; }, _calculatePointsDistance = function(p1, p2) { _tempPoint.x = Math.abs( p1.x - p2.x ); _tempPoint.y = Math.abs( p1.y - p2.y ); return Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y); }, _stopDragUpdateLoop = function() { if(_dragAnimFrame) { _cancelAF(_dragAnimFrame); _dragAnimFrame = null; } }, _dragUpdateLoop = function() { if(_isDragging) { _dragAnimFrame = _requestAF(_dragUpdateLoop); _renderMovement(); } }, _canPan = function() { return !(_options.scaleMode === 'fit' && _currZoomLevel === self.currItem.initialZoomLevel); }, // find the closest parent DOM element _closestElement = function(el, fn) { if(!el || el === document) { return false; } // don't search elements above pswp__scroll-wrap if(el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1 ) { return false; } if( fn(el) ) { return el; } return _closestElement(el.parentNode, fn); }, _preventObj = {}, _preventDefaultEventBehaviour = function(e, isDown) { _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement); _shout('preventDragEvent', e, isDown, _preventObj); return _preventObj.prevent; }, _convertTouchToPoint = function(touch, p) { p.x = touch.pageX; p.y = touch.pageY; p.id = touch.identifier; return p; }, _findCenterOfPoints = function(p1, p2, pCenter) { pCenter.x = (p1.x + p2.x) * 0.5; pCenter.y = (p1.y + p2.y) * 0.5; }, _pushPosPoint = function(time, x, y) { if(time - _gestureCheckSpeedTime > 50) { var o = _posPoints.length > 2 ? _posPoints.shift() : {}; o.x = x; o.y = y; _posPoints.push(o); _gestureCheckSpeedTime = time; } }, _calculateVerticalDragOpacityRatio = function() { var yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position return 1 - Math.abs( yOffset / (_viewportSize.y / 2) ); }, // points pool, reused during touch events _ePoint1 = {}, _ePoint2 = {}, _tempPointsArr = [], _tempCounter, _getTouchPoints = function(e) { // clean up previous points, without recreating array while(_tempPointsArr.length > 0) { _tempPointsArr.pop(); } if(!_pointerEventEnabled) { if(e.type.indexOf('touch') > -1) { if(e.touches && e.touches.length > 0) { _tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1); if(e.touches.length > 1) { _tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2); } } } else { _ePoint1.x = e.pageX; _ePoint1.y = e.pageY; _ePoint1.id = ''; _tempPointsArr[0] = _ePoint1;//_ePoint1; } } else { _tempCounter = 0; // we can use forEach, as pointer events are supported only in modern browsers _currPointers.forEach(function(p) { if(_tempCounter === 0) { _tempPointsArr[0] = p; } else if(_tempCounter === 1) { _tempPointsArr[1] = p; } _tempCounter++; }); } return _tempPointsArr; }, _panOrMoveMainScroll = function(axis, delta) { var panFriction, overDiff = 0, newOffset = _panOffset[axis] + delta[axis], startOverDiff, dir = delta[axis] > 0, newMainScrollPosition = _mainScrollPos.x + delta.x, mainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x, newPanPos, newMainScrollPos; // calculate fdistance over the bounds and friction if(newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) { panFriction = _options.panEndFriction; // Linear increasing of friction, so at 1/4 of viewport it's at max value. // Looks not as nice as was expected. Left for history. // panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) ); } else { panFriction = 1; } newOffset = _panOffset[axis] + delta[axis] * panFriction; // move main scroll or start panning if(_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) { if(!_currZoomElementStyle) { newMainScrollPos = newMainScrollPosition; } else if(_direction === 'h' && axis === 'x' && !_zoomStarted ) { if(dir) { if(newOffset > _currPanBounds.min[axis]) { panFriction = _options.panEndFriction; overDiff = _currPanBounds.min[axis] - newOffset; startOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis]; } // drag right if( (startOverDiff 1 ) { newMainScrollPos = newMainScrollPosition; if(mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) { newMainScrollPos = _startMainScrollPos.x; } } else { if(_currPanBounds.min.x !== _currPanBounds.max.x) { newPanPos = newOffset; } } } else { if(newOffset < _currPanBounds.max[axis] ) { panFriction =_options.panEndFriction; overDiff = newOffset - _currPanBounds.max[axis]; startOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis]; } if( (startOverDiff 0) && _getNumItems() > 1 ) { newMainScrollPos = newMainScrollPosition; if(mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) { newMainScrollPos = _startMainScrollPos.x; } } else { if(_currPanBounds.min.x !== _currPanBounds.max.x) { newPanPos = newOffset; } } } // } if(axis === 'x') { if(newMainScrollPos !== undefined) { _moveMainScroll(newMainScrollPos, true); if(newMainScrollPos === _startMainScrollPos.x) { _mainScrollShifted = false; } else { _mainScrollShifted = true; } } if(_currPanBounds.min.x !== _currPanBounds.max.x) { if(newPanPos !== undefined) { _panOffset.x = newPanPos; } else if(!_mainScrollShifted) { _panOffset.x += delta.x * panFriction; } } return newMainScrollPos !== undefined; } } if(!_mainScrollAnimating) { if(!_mainScrollShifted) { if(_currZoomLevel > self.currItem.fitRatio) { _panOffset[axis] += delta[axis] * panFriction; } } } }, // Pointerdown/touchstart/mousedown handler _onDragStart = function(e) { // Allow dragging only via left mouse button. // As this handler is not added in IE8 - we ignore e.which // // http://www.quirksmode.org/js/events_properties.html // https://developer.mozilla.org/en-US/docs/Web/API/event.button if(e.type === 'mousedown' && e.button > 0 ) { return; } if(_initialZoomRunning) { e.preventDefault(); return; } if(_oldAndroidTouchEndTimeout && e.type === 'mousedown') { return; } if(_preventDefaultEventBehaviour(e, true)) { e.preventDefault(); } _shout('pointerDown'); if(_pointerEventEnabled) { var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id'); if(pointerIndex < 0) { pointerIndex = _currPointers.length; } _currPointers[pointerIndex] = {x:e.pageX, y:e.pageY, id: e.pointerId}; } var startPointsList = _getTouchPoints(e), numPoints = startPointsList.length; _currentPoints = null; _stopAllAnimations(); // init drag if(!_isDragging || numPoints === 1) { _isDragging = _isFirstMove = true; framework.bind(window, _upMoveEvents, self); _isZoomingIn = _wasOverInitialZoom = _opacityChanged = _verticalDragInitiated = _mainScrollShifted = _moved = _isMultitouch = _zoomStarted = false; _direction = null; _shout('firstTouchStart', startPointsList); _equalizePoints(_startPanOffset, _panOffset); _currPanDist.x = _currPanDist.y = 0; _equalizePoints(_currPoint, startPointsList[0]); _equalizePoints(_startPoint, _currPoint); //_equalizePoints(_startMainScrollPos, _mainScrollPos); _startMainScrollPos.x = _slideSize.x * _currPositionIndex; _posPoints = [{ x: _currPoint.x, y: _currPoint.y }]; _gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime(); //_mainScrollAnimationEnd(true); _calculatePanBounds( _currZoomLevel, true ); // Start rendering _stopDragUpdateLoop(); _dragUpdateLoop(); } // init zoom if(!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) { _startZoomLevel = _currZoomLevel; _zoomStarted = false; // true if zoom changed at least once _isZooming = _isMultitouch = true; _currPanDist.y = _currPanDist.x = 0; _equalizePoints(_startPanOffset, _panOffset); _equalizePoints(p, startPointsList[0]); _equalizePoints(p2, startPointsList[1]); _findCenterOfPoints(p, p2, _currCenterPoint); _midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x; _midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y; _currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2); } }, // Pointermove/touchmove/mousemove handler _onDragMove = function(e) { e.preventDefault(); if(_pointerEventEnabled) { var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id'); if(pointerIndex > -1) { var p = _currPointers[pointerIndex]; p.x = e.pageX; p.y = e.pageY; } } if(_isDragging) { var touchesList = _getTouchPoints(e); if(!_direction && !_moved && !_isZooming) { if(_mainScrollPos.x !== _slideSize.x * _currPositionIndex) { // if main scroll position is shifted – direction is always horizontal _direction = 'h'; } else { var diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y); // check the direction of movement if(Math.abs(diff) >= DIRECTION_CHECK_OFFSET) { _direction = diff > 0 ? 'h' : 'v'; _currentPoints = touchesList; } } } else { _currentPoints = touchesList; } } }, // _renderMovement = function() { if(!_currentPoints) { return; } var numPoints = _currentPoints.length; if(numPoints === 0) { return; } _equalizePoints(p, _currentPoints[0]); delta.x = p.x - _currPoint.x; delta.y = p.y - _currPoint.y; if(_isZooming && numPoints > 1) { // Handle behaviour for more than 1 point _currPoint.x = p.x; _currPoint.y = p.y; // check if one of two points changed if( !delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2) ) { return; } _equalizePoints(p2, _currentPoints[1]); if(!_zoomStarted) { _zoomStarted = true; _shout('zoomGestureStarted'); } // Distance between two points var pointsDistance = _calculatePointsDistance(p,p2); var zoomLevel = _calculateZoomLevel(pointsDistance); // slightly over the of initial zoom level if(zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) { _wasOverInitialZoom = true; } // Apply the friction if zoom level is out of the bounds var zoomFriction = 1, minZoomLevel = _getMinZoomLevel(), maxZoomLevel = _getMaxZoomLevel(); if ( zoomLevel < minZoomLevel ) { if(_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel 1) { zoomFriction = 1; } zoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3); } } else if ( zoomLevel > maxZoomLevel ) { // 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5 zoomFriction = (zoomLevel - maxZoomLevel) / ( minZoomLevel * 6 ); if(zoomFriction > 1) { zoomFriction = 1; } zoomLevel = maxZoomLevel + zoomFriction * minZoomLevel; } if(zoomFriction < 0) { zoomFriction = 0; } // distance between touch points after friction is applied _currPointsDistance = pointsDistance; // _centerPoint - The point in the middle of two pointers _findCenterOfPoints(p, p2, _centerPoint); // paning with two pointers pressed _currPanDist.x += _centerPoint.x - _currCenterPoint.x; _currPanDist.y += _centerPoint.y - _currCenterPoint.y; _equalizePoints(_currCenterPoint, _centerPoint); _panOffset.x = _calculatePanOffset('x', zoomLevel); _panOffset.y = _calculatePanOffset('y', zoomLevel); _isZoomingIn = zoomLevel > _currZoomLevel; _currZoomLevel = zoomLevel; _applyCurrentZoomPan(); } else { // handle behaviour for one point (dragging or panning) if(!_direction) { return; } if(_isFirstMove) { _isFirstMove = false; // subtract drag distance that was used during the detection direction if( Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) { delta.x -= _currentPoints[0].x - _startPoint.x; } if( Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) { delta.y -= _currentPoints[0].y - _startPoint.y; } } _currPoint.x = p.x; _currPoint.y = p.y; // do nothing if pointers position hasn't changed if(delta.x === 0 && delta.y === 0) { return; } if(_direction === 'v' && _options.closeOnVerticalDrag) { if(!_canPan()) { _currPanDist.y += delta.y; _panOffset.y += delta.y; var opacityRatio = _calculateVerticalDragOpacityRatio(); _verticalDragInitiated = true; _shout('onVerticalDrag', opacityRatio); _applyBgOpacity(opacityRatio); _applyCurrentZoomPan(); return ; } } _pushPosPoint(_getCurrentTime(), p.x, p.y); _moved = true; _currPanBounds = self.currItem.bounds; var mainScrollChanged = _panOrMoveMainScroll('x', delta); if(!mainScrollChanged) { _panOrMoveMainScroll('y', delta); _roundPoint(_panOffset); _applyCurrentZoomPan(); } } }, // Pointerup/pointercancel/touchend/touchcancel/mouseup event handler _onDragRelease = function(e) { if(_features.isOldAndroid ) { if(_oldAndroidTouchEndTimeout && e.type === 'mouseup') { return; } // on Android (v4.1, 4.2, 4.3 & possibly older) // ghost mousedown/up event isn't preventable via e.preventDefault, // which causes fake mousedown event // so we block mousedown/up for 600ms if( e.type.indexOf('touch') > -1 ) { clearTimeout(_oldAndroidTouchEndTimeout); _oldAndroidTouchEndTimeout = setTimeout(function() { _oldAndroidTouchEndTimeout = 0; }, 600); } } _shout('pointerUp'); if(_preventDefaultEventBehaviour(e, false)) { e.preventDefault(); } var releasePoint; if(_pointerEventEnabled) { var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id'); if(pointerIndex > -1) { releasePoint = _currPointers.splice(pointerIndex, 1)[0]; if(navigator.pointerEnabled) { releasePoint.type = e.pointerType || 'mouse'; } else { var MSPOINTER_TYPES = { 4: 'mouse', // event.MSPOINTER_TYPE_MOUSE 2: 'touch', // event.MSPOINTER_TYPE_TOUCH 3: 'pen' // event.MSPOINTER_TYPE_PEN }; releasePoint.type = MSPOINTER_TYPES[e.pointerType]; if(!releasePoint.type) { releasePoint.type = e.pointerType || 'mouse'; } } } } var touchList = _getTouchPoints(e), gestureType, numPoints = touchList.length; if(e.type === 'mouseup') { numPoints = 0; } // Do nothing if there were 3 touch points or more if(numPoints === 2) { _currentPoints = null; return true; } // if second pointer released if(numPoints === 1) { _equalizePoints(_startPoint, touchList[0]); } // pointer hasn't moved, send \"tap release\" point if(numPoints === 0 && !_direction && !_mainScrollAnimating) { if(!releasePoint) { if(e.type === 'mouseup') { releasePoint = {x: e.pageX, y: e.pageY, type:'mouse'}; } else if(e.changedTouches && e.changedTouches[0]) { releasePoint = {x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY, type:'touch'}; } } _shout('touchRelease', e, releasePoint); } // Difference in time between releasing of two last touch points (zoom gesture) var releaseTimeDiff = -1; // Gesture completed, no pointers left if(numPoints === 0) { _isDragging = false; framework.unbind(window, _upMoveEvents, self); _stopDragUpdateLoop(); if(_isZooming) { // Two points released at the same time releaseTimeDiff = 0; } else if(_lastReleaseTime !== -1) { releaseTimeDiff = _getCurrentTime() - _lastReleaseTime; } } _lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1; if(releaseTimeDiff !== -1 && releaseTimeDiff < 150) { gestureType = 'zoom'; } else { gestureType = 'swipe'; } if(_isZooming && numPoints < 2) { _isZooming = false; // Only second point released if(numPoints === 1) { gestureType = 'zoomPointerUp'; } _shout('zoomGestureEnded'); } _currentPoints = null; if(!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) { // nothing to animate return; } _stopAllAnimations(); if(!_releaseAnimData) { _releaseAnimData = _initDragReleaseAnimationData(); } _releaseAnimData.calculateSwipeSpeed('x'); if(_verticalDragInitiated) { var opacityRatio = _calculateVerticalDragOpacityRatio(); if(opacityRatio < _options.verticalDragRange) { self.close(); } else { var initalPanY = _panOffset.y, initialBgOpacity = _bgOpacity; _animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function(now) { _panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY; _applyBgOpacity( (1 - initialBgOpacity) * now + initialBgOpacity ); _applyCurrentZoomPan(); }); _shout('onVerticalDrag', 1); } return; } // main scroll if( (_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) { var itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData); if(itemChanged) { return; } gestureType = 'zoomPointerUp'; } // prevent zoom/pan animation when main scroll animation runs if(_mainScrollAnimating) { return; } // Complete simple zoom gesture (reset zoom level if it's out of the bounds) if(gestureType !== 'swipe') { _completeZoomGesture(); return; } // Complete pan gesture if main scroll is not shifted, and it's possible to pan current image if(!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) { _completePanGesture(_releaseAnimData); } }, // Returns object with data about gesture // It's created only once and then reused _initDragReleaseAnimationData = function() { // temp local vars var lastFlickDuration, tempReleasePos; // s = this var s = { lastFlickOffset: {}, lastFlickDist: {}, lastFlickSpeed: {}, slowDownRatio: {}, slowDownRatioReverse: {}, speedDecelerationRatio: {}, speedDecelerationRatioAbs: {}, distanceOffset: {}, backAnimDestination: {}, backAnimStarted: {}, calculateSwipeSpeed: function(axis) { if( _posPoints.length > 1) { lastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50; tempReleasePos = _posPoints[_posPoints.length-2][axis]; } else { lastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration tempReleasePos = _startPoint[axis]; } s.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos; s.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]); if(s.lastFlickDist[axis] > 20) { s.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration; } else { s.lastFlickSpeed[axis] = 0; } if( Math.abs(s.lastFlickSpeed[axis]) < 0.1 ) { s.lastFlickSpeed[axis] = 0; } s.slowDownRatio[axis] = 0.95; s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis]; s.speedDecelerationRatio[axis] = 1; }, calculateOverBoundsAnimOffset: function(axis, speed) { if(!s.backAnimStarted[axis]) { if(_panOffset[axis] > _currPanBounds.min[axis]) { s.backAnimDestination[axis] = _currPanBounds.min[axis]; } else if(_panOffset[axis] < _currPanBounds.max[axis]) { s.backAnimDestination[axis] = _currPanBounds.max[axis]; } if(s.backAnimDestination[axis] !== undefined) { s.slowDownRatio[axis] = 0.7; s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis]; if(s.speedDecelerationRatioAbs[axis] < 0.05) { s.lastFlickSpeed[axis] = 0; s.backAnimStarted[axis] = true; _animateProp('bounceZoomPan'+axis,_panOffset[axis], s.backAnimDestination[axis], speed || 300, framework.easing.sine.out, function(pos) { _panOffset[axis] = pos; _applyCurrentZoomPan(); } ); } } } }, // Reduces the speed by slowDownRatio (per 10ms) calculateAnimOffset: function(axis) { if(!s.backAnimStarted[axis]) { s.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] + s.slowDownRatioReverse[axis] - s.slowDownRatioReverse[axis] * s.timeDiff / 10); s.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]); s.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff; _panOffset[axis] += s.distanceOffset[axis]; } }, panAnimLoop: function() { if ( _animations.zoomPan ) { _animations.zoomPan.raf = _requestAF(s.panAnimLoop); s.now = _getCurrentTime(); s.timeDiff = s.now - s.lastNow; s.lastNow = s.now; s.calculateAnimOffset('x'); s.calculateAnimOffset('y'); _applyCurrentZoomPan(); s.calculateOverBoundsAnimOffset('x'); s.calculateOverBoundsAnimOffset('y'); if (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) { // round pan position _panOffset.x = Math.round(_panOffset.x); _panOffset.y = Math.round(_panOffset.y); _applyCurrentZoomPan(); _stopAnimation('zoomPan'); return; } } } }; return s; }, _completePanGesture = function(animData) { // calculate swipe speed for Y axis (paanning) animData.calculateSwipeSpeed('y'); _currPanBounds = self.currItem.bounds; animData.backAnimDestination = {}; animData.backAnimStarted = {}; // Avoid acceleration animation if speed is too low if(Math.abs(animData.lastFlickSpeed.x) 20) ) { // go to prev item itemsDiff = -1; } else if(totalShiftDist < -MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20) ) { // go to next item itemsDiff = 1; } } var nextCircle; if(itemsDiff) { _currentItemIndex += itemsDiff; if(_currentItemIndex < 0) { _currentItemIndex = _options.loop ? _getNumItems()-1 : 0; nextCircle = true; } else if(_currentItemIndex >= _getNumItems()) { _currentItemIndex = _options.loop ? 0 : _getNumItems()-1; nextCircle = true; } if(!nextCircle || _options.loop) { _indexDiff += itemsDiff; _currPositionIndex -= itemsDiff; itemChanged = true; } } var animateToX = _slideSize.x * _currPositionIndex; var animateToDist = Math.abs( animateToX - _mainScrollPos.x ); var finishAnimDuration; if(!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) { // \"return to current\" duration, e.g. when dragging from slide 0 to -1 finishAnimDuration = 333; } else { finishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ? animateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) : 333; finishAnimDuration = Math.min(finishAnimDuration, 400); finishAnimDuration = Math.max(finishAnimDuration, 250); } if(_currZoomedItemIndex === _currentItemIndex) { itemChanged = false; } _mainScrollAnimating = true; _shout('mainScrollAnimStart'); _animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out, _moveMainScroll, function() { _stopAllAnimations(); _mainScrollAnimating = false; _currZoomedItemIndex = -1; if(itemChanged || _currZoomedItemIndex !== _currentItemIndex) { self.updateCurrItem(); } _shout('mainScrollAnimComplete'); } ); if(itemChanged) { self.updateCurrItem(true); } return itemChanged; }, _calculateZoomLevel = function(touchesDistance) { return 1 / _startPointsDistance * touchesDistance * _startZoomLevel; }, // Resets zoom if it's out of bounds _completeZoomGesture = function() { var destZoomLevel = _currZoomLevel, minZoomLevel = _getMinZoomLevel(), maxZoomLevel = _getMaxZoomLevel(); if ( _currZoomLevel < minZoomLevel ) { destZoomLevel = minZoomLevel; } else if ( _currZoomLevel > maxZoomLevel ) { destZoomLevel = maxZoomLevel; } var destOpacity = 1, onUpdate, initialOpacity = _bgOpacity; if(_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) { //_closedByScroll = true; self.close(); return true; } if(_opacityChanged) { onUpdate = function(now) { _applyBgOpacity( (destOpacity - initialOpacity) * now + initialOpacity ); }; } self.zoomTo(destZoomLevel, 0, 200, framework.easing.cubic.out, onUpdate); return true; }; _registerModule('Gestures', { publicMethods: { initGestures: function() { // helper function that builds touch/pointer/mouse events var addEventNames = function(pref, down, move, up, cancel) { _dragStartEvent = pref + down; _dragMoveEvent = pref + move; _dragEndEvent = pref + up; if(cancel) { _dragCancelEvent = pref + cancel; } else { _dragCancelEvent = ''; } }; _pointerEventEnabled = _features.pointerEvent; if(_pointerEventEnabled && _features.touch) { // we don't need touch events, if browser supports pointer events _features.touch = false; } if(_pointerEventEnabled) { if(navigator.pointerEnabled) { addEventNames('pointer', 'down', 'move', 'up', 'cancel'); } else { // IE10 pointer events are case-sensitive addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel'); } } else if(_features.touch) { addEventNames('touch', 'start', 'move', 'end', 'cancel'); _likelyTouchDevice = true; } else { addEventNames('mouse', 'down', 'move', 'up'); } _upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent + ' ' + _dragCancelEvent; _downEvents = _dragStartEvent; if(_pointerEventEnabled && !_likelyTouchDevice) { _likelyTouchDevice = (navigator.maxTouchPoints > 1) || (navigator.msMaxTouchPoints > 1); } // make variable public self.likelyTouchDevice = _likelyTouchDevice; _globalEventHandlers[_dragStartEvent] = _onDragStart; _globalEventHandlers[_dragMoveEvent] = _onDragMove; _globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken if(_dragCancelEvent) { _globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent]; } // Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input. if(_features.touch) { _downEvents += ' mousedown'; _upMoveEvents += ' mousemove mouseup'; _globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent]; _globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent]; _globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent]; } if(!_likelyTouchDevice) { // don't allow pan to next slide from zoomed state on Desktop _options.allowPanToNext = false; } } } }); /*>>gestures*/ /*>>show-hide-transition*/ /** * show-hide-transition.js: * * Manages initial opening or closing transition. * * If you're not planning to use transition for gallery at all, * you may set options hideAnimationDuration and showAnimationDuration to 0, * and just delete startAnimation function. * */ var _showOrHideTimeout, _showOrHide = function(item, img, out, completeFn) { if(_showOrHideTimeout) { clearTimeout(_showOrHideTimeout); } _initialZoomRunning = true; _initialContentSet = true; // dimensions of small thumbnail {x:,y:,w:}. // Height is optional, as calculated based on large image. var thumbBounds; if(item.initialLayout) { thumbBounds = item.initialLayout; item.initialLayout = null; } else { thumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex); } var duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration; var onComplete = function() { _stopAnimation('initialZoom'); if(!out) { _applyBgOpacity(1); if(img) { img.style.display = 'block'; } framework.addClass(template, 'pswp--animated-in'); _shout('initialZoom' + (out ? 'OutEnd' : 'InEnd')); } else { self.template.removeAttribute('style'); self.bg.removeAttribute('style'); } if(completeFn) { completeFn(); } _initialZoomRunning = false; }; // if bounds aren't provided, just open gallery without animation if(!duration || !thumbBounds || thumbBounds.x === undefined) { _shout('initialZoom' + (out ? 'Out' : 'In') ); _currZoomLevel = item.initialZoomLevel; _equalizePoints(_panOffset, item.initialPosition ); _applyCurrentZoomPan(); template.style.opacity = out ? 0 : 1; _applyBgOpacity(1); if(duration) { setTimeout(function() { onComplete(); }, duration); } else { onComplete(); } return; } var startAnimation = function() { var closeWithRaf = _closedByScroll, fadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity; // apply hw-acceleration to image if(item.miniImg) { item.miniImg.style.webkitBackfaceVisibility = 'hidden'; } if(!out) { _currZoomLevel = thumbBounds.w / item.w; _panOffset.x = thumbBounds.x; _panOffset.y = thumbBounds.y - _initalWindowScrollY; self[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001; _applyCurrentZoomPan(); } _registerStartAnimation('initialZoom'); if(out && !closeWithRaf) { framework.removeClass(template, 'pswp--animated-in'); } if(fadeEverything) { if(out) { framework[ (closeWithRaf ? 'remove' : 'add') + 'Class' ](template, 'pswp--animate_opacity'); } else { setTimeout(function() { framework.addClass(template, 'pswp--animate_opacity'); }, 30); } } _showOrHideTimeout = setTimeout(function() { _shout('initialZoom' + (out ? 'Out' : 'In') ); if(!out) { // \"in\" animation always uses CSS transitions (instead of rAF). // CSS transition work faster here, // as developer may also want to animate other things, // like ui on top of sliding area, which can be animated just via CSS _currZoomLevel = item.initialZoomLevel; _equalizePoints(_panOffset, item.initialPosition ); _applyCurrentZoomPan(); _applyBgOpacity(1); if(fadeEverything) { template.style.opacity = 1; } else { _applyBgOpacity(1); } _showOrHideTimeout = setTimeout(onComplete, duration + 20); } else { // \"out\" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position var destZoomLevel = thumbBounds.w / item.w, initialPanOffset = { x: _panOffset.x, y: _panOffset.y }, initialZoomLevel = _currZoomLevel, initalBgOpacity = _bgOpacity, onUpdate = function(now) { if(now === 1) { _currZoomLevel = destZoomLevel; _panOffset.x = thumbBounds.x; _panOffset.y = thumbBounds.y - _currentWindowScrollY; } else { _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel; _panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x; _panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y; } _applyCurrentZoomPan(); if(fadeEverything) { template.style.opacity = 1 - now; } else { _applyBgOpacity( initalBgOpacity - now * initalBgOpacity ); } }; if(closeWithRaf) { _animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete); } else { onUpdate(1); _showOrHideTimeout = setTimeout(onComplete, duration + 20); } } }, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and // create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows). // Which avoids lag at the beginning of scale transition. }; startAnimation(); }; /*>>show-hide-transition*/ /*>>items-controller*/ /** * * Controller manages gallery items, their dimensions, and their content. * */ var _items, _tempPanAreaSize = {}, _imagesToAppendPool = [], _initialContentSet, _initialZoomRunning, _controllerDefaultOptions = { index: 0, errorMsg: 'The image could not be loaded.', forceProgressiveLoading: false, // TODO preload: [1,1], getNumItemsFn: function() { return _items.length; } }; var _getItemAt, _getNumItems, _initialIsLoop, _getZeroBounds = function() { return { center:{x:0,y:0}, max:{x:0,y:0}, min:{x:0,y:0} }; }, _calculateSingleItemPanBounds = function(item, realPanElementW, realPanElementH ) { var bounds = item.bounds; // position of element when it's centered bounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2); bounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top; // maximum pan position bounds.max.x = (realPanElementW > _tempPanAreaSize.x) ? Math.round(_tempPanAreaSize.x - realPanElementW) : bounds.center.x; bounds.max.y = (realPanElementH > _tempPanAreaSize.y) ? Math.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top : bounds.center.y; // minimum pan position bounds.min.x = (realPanElementW > _tempPanAreaSize.x) ? 0 : bounds.center.x; bounds.min.y = (realPanElementH > _tempPanAreaSize.y) ? item.vGap.top : bounds.center.y; }, _calculateItemSize = function(item, viewportSize, zoomLevel) { if (item.src && !item.loadError) { var isInitial = !zoomLevel; if(isInitial) { if(!item.vGap) { item.vGap = {top:0,bottom:0}; } // allows overriding vertical margin for individual items _shout('parseVerticalMargin', item); } _tempPanAreaSize.x = viewportSize.x; _tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom; if (isInitial) { var hRatio = _tempPanAreaSize.x / item.w; var vRatio = _tempPanAreaSize.y / item.h; item.fitRatio = hRatio < vRatio ? hRatio : vRatio; //item.fillRatio = hRatio > vRatio ? hRatio : vRatio; var scaleMode = _options.scaleMode; if (scaleMode === 'orig') { zoomLevel = 1; } else if (scaleMode === 'fit') { zoomLevel = item.fitRatio; } if (zoomLevel > 1) { zoomLevel = 1; } item.initialZoomLevel = zoomLevel; if(!item.bounds) { // reuse bounds object item.bounds = _getZeroBounds(); } } if(!zoomLevel) { return; } _calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel); if (isInitial && zoomLevel === item.initialZoomLevel) { item.initialPosition = item.bounds.center; } return item.bounds; } else { item.w = item.h = 0; item.initialZoomLevel = item.fitRatio = 1; item.bounds = _getZeroBounds(); item.initialPosition = item.bounds.center; // if it's not image, we return zero bounds (content is not zoomable) return item.bounds; } }, _appendImage = function(index, item, baseDiv, img, preventAnimation, keepPlaceholder) { if(item.loadError) { return; } if(img) { item.imageAppended = true; _setImageSize(item, img, (item === self.currItem && _renderMaxResolution) ); baseDiv.appendChild(img); if(keepPlaceholder) { setTimeout(function() { if(item && item.loaded && item.placeholder) { item.placeholder.style.display = 'none'; item.placeholder = null; } }, 500); } } }, _preloadImage = function(item) { item.loading = true; item.loaded = false; var img = item.img = framework.createEl('pswp__img', 'img'); var onComplete = function() { item.loading = false; item.loaded = true; if(item.loadComplete) { item.loadComplete(item); } else { item.img = null; // no need to store image object } img.onload = img.onerror = null; img = null; }; img.onload = onComplete; img.onerror = function() { item.loadError = true; onComplete(); }; img.src = item.src;// + '?a=' + Math.random(); return img; }, _checkForError = function(item, cleanUp) { if(item.src && item.loadError && item.container) { if(cleanUp) { item.container.innerHTML = ''; } item.container.innerHTML = _options.errorMsg.replace('%url%', item.src ); return true; } }, _setImageSize = function(item, img, maxRes) { if(!item.src) { return; } if(!img) { img = item.container.lastChild; } var w = maxRes ? item.w : Math.round(item.w * item.fitRatio), h = maxRes ? item.h : Math.round(item.h * item.fitRatio); if(item.placeholder && !item.loaded) { item.placeholder.style.width = w + 'px'; item.placeholder.style.height = h + 'px'; } img.style.width = w + 'px'; img.style.height = h + 'px'; }, _appendImagesPool = function() { if(_imagesToAppendPool.length) { var poolItem; for(var i = 0; i < _imagesToAppendPool.length; i++) { poolItem = _imagesToAppendPool[i]; if( poolItem.holder.index === poolItem.index ) { _appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder); } } _imagesToAppendPool = []; } }; _registerModule('Controller', { publicMethods: { lazyLoadItem: function(index) { index = _getLoopedId(index); var item = _getItemAt(index); if(!item || ((item.loaded || item.loading) && !_itemsNeedUpdate)) { return; } _shout('gettingData', index, item); if (!item.src) { return; } _preloadImage(item); }, initController: function() { framework.extend(_options, _controllerDefaultOptions, true); self.items = _items = items; _getItemAt = self.getItemAt; _getNumItems = _options.getNumItemsFn; //self.getNumItems; _initialIsLoop = _options.loop; if(_getNumItems() < 3) { _options.loop = false; // disable loop if less then 3 items } _listen('beforeChange', function(diff) { var p = _options.preload, isNext = diff === null ? true : (diff >= 0), preloadBefore = Math.min(p[0], _getNumItems() ), preloadAfter = Math.min(p[1], _getNumItems() ), i; for(i = 1; i 1200; // 1200 - to eliminate touch devices with large screen (like Chromebook Pixel) }, setContent: function(holder, index) { if(_options.loop) { index = _getLoopedId(index); } var prevItem = self.getItemAt(holder.index); if(prevItem) { prevItem.container = null; } var item = self.getItemAt(index), img; if(!item) { holder.el.innerHTML = ''; return; } // allow to override data _shout('gettingData', index, item); holder.index = index; holder.item = item; // base container DIV is created only once for each of 3 holders var baseDiv = item.container = framework.createEl('pswp__zoom-wrap'); if(!item.src && item.html) { if(item.html.tagName) { baseDiv.appendChild(item.html); } else { baseDiv.innerHTML = item.html; } } _checkForError(item); _calculateItemSize(item, _viewportSize); if(item.src && !item.loadError && !item.loaded) { item.loadComplete = function(item) { // gallery closed before image finished loading if(!_isOpen) { return; } // check if holder hasn't changed while image was loading if(holder && holder.index === index ) { if( _checkForError(item, true) ) { item.loadComplete = item.img = null; _calculateItemSize(item, _viewportSize); _applyZoomPanToItem(item); if(holder.index === _currentItemIndex) { // recalculate dimensions self.updateCurrZoomItem(); } return; } if( !item.imageAppended ) { if(_features.transform && (_mainScrollAnimating || _initialZoomRunning) ) { _imagesToAppendPool.push({ item:item, baseDiv:baseDiv, img:item.img, index:index, holder:holder, clearPlaceholder:true }); } else { _appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true); } } else { // remove preloader & mini-img if(!_initialZoomRunning && item.placeholder) { item.placeholder.style.display = 'none'; item.placeholder = null; } } } item.loadComplete = null; item.img = null; // no need to store image element after it's added _shout('imageLoadComplete', index, item); }; if(framework.features.transform) { var placeholderClassName = 'pswp__img pswp__img--placeholder'; placeholderClassName += (item.msrc ? '' : ' pswp__img--placeholder--blank'); var placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : ''); if(item.msrc) { placeholder.src = item.msrc; } _setImageSize(item, placeholder); baseDiv.appendChild(placeholder); item.placeholder = placeholder; } if(!item.loading) { _preloadImage(item); } if( self.allowProgressiveImg() ) { // just append image if(!_initialContentSet && _features.transform) { _imagesToAppendPool.push({ item:item, baseDiv:baseDiv, img:item.img, index:index, holder:holder }); } else { _appendImage(index, item, baseDiv, item.img, true, true); } } } else if(item.src && !item.loadError) { // image object is created every time, due to bugs of image loading & delay when switching images img = framework.createEl('pswp__img', 'img'); img.style.opacity = 1; img.src = item.src; _setImageSize(item, img); _appendImage(index, item, baseDiv, img, true); } if(!_initialContentSet && index === _currentItemIndex) { _currZoomElementStyle = baseDiv.style; _showOrHide(item, (img ||item.img) ); } else { _applyZoomPanToItem(item); } holder.el.innerHTML = ''; holder.el.appendChild(baseDiv); }, cleanSlide: function( item ) { if(item.img ) { item.img.onload = item.img.onerror = null; } item.loaded = item.loading = item.img = item.imageAppended = false; } } }); /*>>items-controller*/ /*>>tap*/ /** * tap.js: * * Displatches tap and double-tap events. * */ var tapTimer, tapReleasePoint = {}, _dispatchTapEvent = function(origEvent, releasePoint, pointerType) { var e = document.createEvent( 'CustomEvent' ), eDetail = { origEvent:origEvent, target:origEvent.target, releasePoint: releasePoint, pointerType:pointerType || 'touch' }; e.initCustomEvent( 'pswpTap', true, true, eDetail ); origEvent.target.dispatchEvent(e); }; _registerModule('Tap', { publicMethods: { initTap: function() { _listen('firstTouchStart', self.onTapStart); _listen('touchRelease', self.onTapRelease); _listen('destroy', function() { tapReleasePoint = {}; tapTimer = null; }); }, onTapStart: function(touchList) { if(touchList.length > 1) { clearTimeout(tapTimer); tapTimer = null; } }, onTapRelease: function(e, releasePoint) { if(!releasePoint) { return; } if(!_moved && !_isMultitouch && !_numAnimations) { var p0 = releasePoint; if(tapTimer) { clearTimeout(tapTimer); tapTimer = null; // Check if taped on the same place if ( _isNearbyPoints(p0, tapReleasePoint) ) { _shout('doubleTap', p0); return; } } if(releasePoint.type === 'mouse') { _dispatchTapEvent(e, releasePoint, 'mouse'); return; } var clickedTagName = e.target.tagName.toUpperCase(); // avoid double tap delay on buttons and elements that have class pswp__single-tap if(clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap') ) { _dispatchTapEvent(e, releasePoint); return; } _equalizePoints(tapReleasePoint, p0); tapTimer = setTimeout(function() { _dispatchTapEvent(e, releasePoint); tapTimer = null; }, 300); } } } }); /*>>tap*/ /*>>desktop-zoom*/ /** * * desktop-zoom.js: * * - Binds mousewheel event for paning zoomed image. * - Manages \"dragging\", \"zoomed-in\", \"zoom-out\" classes. * (which are used for cursors and zoom icon) * - Adds toggleDesktopZoom function. * */ var _wheelDelta; _registerModule('DesktopZoom', { publicMethods: { initDesktopZoom: function() { if(_oldIE) { // no zoom for old IE ( 2) { // close PhotoSwipe // if browser supports transforms & scroll changed enough _closedByScroll = true; self.close(); } } return true; } // allow just one event to fire e.stopPropagation(); // https://developer.mozilla.org/en-US/docs/Web/Events/wheel _wheelDelta.x = 0; if('deltaX' in e) { if(e.deltaMode === 1 /* DOM_DELTA_LINE */) { // 18 - average line height _wheelDelta.x = e.deltaX * 18; _wheelDelta.y = e.deltaY * 18; } else { _wheelDelta.x = e.deltaX; _wheelDelta.y = e.deltaY; } } else if('wheelDelta' in e) { if(e.wheelDeltaX) { _wheelDelta.x = -0.16 * e.wheelDeltaX; } if(e.wheelDeltaY) { _wheelDelta.y = -0.16 * e.wheelDeltaY; } else { _wheelDelta.y = -0.16 * e.wheelDelta; } } else if('detail' in e) { _wheelDelta.y = e.detail; } else { return; } _calculatePanBounds(_currZoomLevel, true); var newPanX = _panOffset.x - _wheelDelta.x, newPanY = _panOffset.y - _wheelDelta.y; // only prevent scrolling in nonmodal mode when not at edges if (_options.modal || ( newPanX = _currPanBounds.max.x && newPanY = _currPanBounds.max.y ) ) { e.preventDefault(); } // TODO: use rAF instead of mousewheel? self.panTo(newPanX, newPanY); }, toggleDesktopZoom: function(centerPoint) { centerPoint = centerPoint || {x:_viewportSize.x/2 + _offset.x, y:_viewportSize.y/2 + _offset.y }; var doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem); var zoomOut = _currZoomLevel === doubleTapZoomLevel; self.mouseZoomedIn = !zoomOut; self.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333); framework[ (!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in'); } } }); /*>>desktop-zoom*/ /*>>history*/ /** * * history.js: * * - Back button to close gallery. * * - Unique URL for each slide: example.com/&pid=1&gid=3 * (where PID is picture index, and GID and gallery index) * * - Switch URL when slides change. * */ var _historyDefaultOptions = { history: true, galleryUID: 1 }; var _historyUpdateTimeout, _hashChangeTimeout, _hashAnimCheckTimeout, _hashChangedByScript, _hashChangedByHistory, _hashReseted, _initialHash, _historyChanged, _closedFromURL, _urlChangedOnce, _windowLoc, _supportsPushState, _getHash = function() { return _windowLoc.hash.substring(1); }, _cleanHistoryTimeouts = function() { if(_historyUpdateTimeout) { clearTimeout(_historyUpdateTimeout); } if(_hashAnimCheckTimeout) { clearTimeout(_hashAnimCheckTimeout); } }, // pid - Picture index // gid - Gallery index _parseItemIndexFromURL = function() { var hash = _getHash(), params = {}; if(hash.length < 5) { // pid=1 return params; } var i, vars = hash.split('&'); for (i = 0; i < vars.length; i++) { if(!vars[i]) { continue; } var pair = vars[i].split('='); if(pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if(_options.galleryPIDs) { // detect custom pid in hash and search for it among the items collection var searchfor = params.pid; params.pid = 0; // if custom pid cannot be found, fallback to the first item for(i = 0; i < _items.length; i++) { if(_items[i].pid === searchfor) { params.pid = i; break; } } } else { params.pid = parseInt(params.pid,10)-1; } if( params.pid < 0 ) { params.pid = 0; } return params; }, _updateHash = function() { if(_hashAnimCheckTimeout) { clearTimeout(_hashAnimCheckTimeout); } if(_numAnimations || _isDragging) { // changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation // that's why we update hash only when no animations running _hashAnimCheckTimeout = setTimeout(_updateHash, 500); return; } if(_hashChangedByScript) { clearTimeout(_hashChangeTimeout); } else { _hashChangedByScript = true; } var pid = (_currentItemIndex + 1); var item = _getItemAt( _currentItemIndex ); if(item.hasOwnProperty('pid')) { // carry forward any custom pid assigned to the item pid = item.pid; } var newHash = _initialHash + '&' + 'gid=' + _options.galleryUID + '&' + 'pid=' + pid; if(!_historyChanged) { if(_windowLoc.hash.indexOf(newHash) === -1) { _urlChangedOnce = true; } // first time - add new hisory record, then just replace } var newURL = _windowLoc.href.split('#')[0] + '#' + newHash; if( _supportsPushState ) { if('#' + newHash !== window.location.hash) { history[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL); } } else { if(_historyChanged) { _windowLoc.replace( newURL ); } else { _windowLoc.hash = newHash; } } _historyChanged = true; _hashChangeTimeout = setTimeout(function() { _hashChangedByScript = false; }, 60); }; _registerModule('History', { publicMethods: { initHistory: function() { framework.extend(_options, _historyDefaultOptions, true); if( !_options.history ) { return; } _windowLoc = window.location; _urlChangedOnce = false; _closedFromURL = false; _historyChanged = false; _initialHash = _getHash(); _supportsPushState = ('pushState' in history); if(_initialHash.indexOf('gid=') > -1) { _initialHash = _initialHash.split('&gid=')[0]; _initialHash = _initialHash.split('?gid=')[0]; } _listen('afterChange', self.updateURL); _listen('unbindEvents', function() { framework.unbind(window, 'hashchange', self.onHashChange); }); var returnToOriginal = function() { _hashReseted = true; if(!_closedFromURL) { if(_urlChangedOnce) { history.back(); } else { if(_initialHash) { _windowLoc.hash = _initialHash; } else { if (_supportsPushState) { // remove hash from url without refreshing it or scrolling to top history.pushState('', document.title, _windowLoc.pathname + _windowLoc.search ); } else { _windowLoc.hash = ''; } } } } _cleanHistoryTimeouts(); }; _listen('unbindEvents', function() { if(_closedByScroll) { // if PhotoSwipe is closed by scroll, we go \"back\" before the closing animation starts // this is done to keep the scroll position returnToOriginal(); } }); _listen('destroy', function() { if(!_hashReseted) { returnToOriginal(); } }); _listen('firstUpdate', function() { _currentItemIndex = _parseItemIndexFromURL().pid; }); var index = _initialHash.indexOf('pid='); if(index > -1) { _initialHash = _initialHash.substring(0, index); if(_initialHash.slice(-1) === '&') { _initialHash = _initialHash.slice(0, -1); } } setTimeout(function() { if(_isOpen) { // hasn't destroyed yet framework.bind(window, 'hashchange', self.onHashChange); } }, 40); }, onHashChange: function() { if(_getHash() === _initialHash) { _closedFromURL = true; self.close(); return; } if(!_hashChangedByScript) { _hashChangedByHistory = true; self.goTo( _parseItemIndexFromURL().pid ); _hashChangedByHistory = false; } }, updateURL: function() { // Delay the update of URL, to avoid lag during transition, // and to not to trigger actions like \"refresh page sound\" or \"blinking favicon\" to often _cleanHistoryTimeouts(); if(_hashChangedByHistory) { return; } if(!_historyChanged) { _updateHash(); // first time } else { _historyUpdateTimeout = setTimeout(_updateHash, 800); } } } }); /*>>history*/ framework.extend(self, publicMethods); }; return PhotoSwipe; });"}],"posts":[{"title":"第6期-6-flex布局","slug":"第6期-6-flex布局","date":"2020-01-16T07:08:23.000Z","updated":"2020-01-19T04:23:10.859Z","comments":true,"path":"2020/01/16/第6期-6-flex布局/","link":"","permalink":"https://137942170.github.io/fwtBlog/2020/01/16/第6期-6-flex布局/","excerpt":"","text":"flex语法一、Flex 布局是什么？弹性布局：任何一个容器都可以指定为 Flex 布局 123box &#123; display:flex; &#125; 行内元素也可以使用 Flex 布局。 123box &#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123;display: -webkit-flex; /* Safari */display: flex;&#125; 二、基本概念容器两根轴 主轴（水平）：开始（main start）、结束（main end）和 交叉轴（垂直）:cross start）、结束（cross end）; 单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性` + flex-direction + flex-wrap + flex-flow + justify-content + align-items + align-content ` ##### 3.1 flex-direction属性 flex-direction属性决定主轴的方向 ` box { flex-direction: row | row-reverse | column | column-reverse; } `","categories":[{"name":"Html","slug":"Html","permalink":"https://137942170.github.io/fwtBlog/categories/Html/"}],"tags":[{"name":"布局","slug":"布局","permalink":"https://137942170.github.io/fwtBlog/tags/布局/"}]},{"title":"什么是函数的防抖和节流","slug":"什么是函数的防抖和节流","date":"2019-09-16T09:23:35.000Z","updated":"2019-09-16T09:25:05.664Z","comments":true,"path":"2019/09/16/什么是函数的防抖和节流/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/09/16/什么是函数的防抖和节流/","excerpt":"","text":"","categories":[{"name":"JS","slug":"JS","permalink":"https://137942170.github.io/fwtBlog/categories/JS/"}],"tags":[{"name":"js面试题","slug":"js面试题","permalink":"https://137942170.github.io/fwtBlog/tags/js面试题/"}]},{"title":"moment 插件基本用法","slug":"moment插件基本用法","date":"2019-09-01T02:15:21.000Z","updated":"2019-09-01T02:32:38.267Z","comments":true,"path":"2019/09/01/moment插件基本用法/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/09/01/moment插件基本用法/","excerpt":"","text":"格式化日期当前时间:1moment().format(&apos;YYYY-MM-DD HH:mm:ss&apos;); 当前日期:1moment().format(&apos;d&apos;); 转换当前时间的Unix时间戳:1moment().format(&apos;X&apos;); 相对时间20170901相对当前日期是2年前1moment(&quot;20170901&quot;, &quot;YYYYMMDD&quot;).fromNow();","categories":[{"name":"JS插件","slug":"JS插件","permalink":"https://137942170.github.io/fwtBlog/categories/JS插件/"}],"tags":[{"name":"JS时间插件","slug":"JS时间插件","permalink":"https://137942170.github.io/fwtBlog/tags/JS时间插件/"}]},{"title":"【ES6】var、let、const的区别","slug":"【ES6】var、let、const的区别","date":"2019-08-20T09:20:12.000Z","updated":"2019-08-20T09:43:57.526Z","comments":true,"path":"2019/08/20/【ES6】var、let、const的区别/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/08/20/【ES6】var、let、const的区别/","excerpt":"","text":"一、块级作用域ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域。 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/javascript&quot;&gt; &#123; var a = 1; console.log(a); // 1 &#125; console.log(a); // 1 // 通过var定义的变量可以跨块作用域访问到。 (function A() &#123; var b = 2; console.log(b); // 2 &#125;)(); // console.log(b); // 报错， // 可见，通过var定义的变量不能跨函数作用域访问到 if(true) &#123; var c = 3; &#125; console.log(c); // 3 for(var i = 0; i &lt; 4; i ++) &#123; var d = 5; &#125;; console.log(i); // 4 (循环结束i已经是4，所以此处i为4) console.log(d); // 5 // if语句和for语句中用var定义的变量可以在外面访问到， // 可见，if语句和for语句属于块作用域，不属于函数作用域。&lt;/script&gt; 二、var、let、const的区别1、var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 2、let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 3、const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。1234567891011121314151617181920212223242526272829303132333435&lt;script type=&quot;text/javascript&quot;&gt; // 块作用域 &#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined &#125; console.log(a); // 1 // console.log(b); // 报错 // console.log(c); // 报错 // 函数作用域 (function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 console.log(f); // 7 &#125;)(); // console.log(d); // 报错 // console.log(e); // 报错 // console.log(f); // 报错&lt;/script&gt; 三、const定义的对象属性是否可以改变上面说到 const 是不能修改的，于是很痛快的说不能，但是回来实际测试后发现错了，在此记录一下 12345678const person = &#123; name : &apos;jiuke&apos;, sex : &apos;男&apos;&#125;person.name = &apos;test&apos;console.log(person.name) 运行上述代码，发现person对象的name属性确实被修改了，这是怎么回事呢？ 因为对象是引用类型的，person中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。 然后我们试着修改一下指针，让person指向一个新对象，果然报错123456789const person = &#123;name : &apos;jiuke&apos;,sex : &apos;男&apos;&#125;person = &#123;name : &apos;test&apos;,sex : &apos;男&apos;&#125;","categories":[{"name":"Es6","slug":"Es6","permalink":"https://137942170.github.io/fwtBlog/categories/Es6/"}],"tags":[{"name":"8月","slug":"8月","permalink":"https://137942170.github.io/fwtBlog/tags/8月/"}]},{"title":"整理的前端基础知识","slug":"整理的前端基础知识","date":"2019-07-31T08:57:54.000Z","updated":"2019-07-31T09:00:52.663Z","comments":true,"path":"2019/07/31/整理的前端基础知识/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/31/整理的前端基础知识/","excerpt":"","text":"前端基础知识什么是一个Web服务器？","categories":[],"tags":[]},{"title":"XSS 与 CSRF 两种跨站攻击","slug":"XSS-与-CSRF-两种跨站攻击","date":"2019-07-18T09:32:14.000Z","updated":"2019-07-18T09:59:27.357Z","comments":true,"path":"2019/07/18/XSS-与-CSRF-两种跨站攻击/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/18/XSS-与-CSRF-两种跨站攻击/","excerpt":"","text":"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://137942170.github.io/fwtBlog/tags/浏览器/"}]},{"title":"第5期:(5)JavaScript基础语法","slug":"第5期-5-JavaScript基础语法","date":"2019-07-12T02:52:39.000Z","updated":"2019-07-12T02:52:39.660Z","comments":true,"path":"2019/07/12/第5期-5-JavaScript基础语法/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/12/第5期-5-JavaScript基础语法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第4期:(4)正则表达式","slug":"第4期-4-正则表达式","date":"2019-07-12T02:42:34.000Z","updated":"2019-07-12T05:33:43.055Z","comments":true,"path":"2019/07/12/第4期-4-正则表达式/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/12/第4期-4-正则表达式/","excerpt":"","text":"正则表达式首先使用一个正则表达式字面量，其由包含在斜杠之间的模式组成: 1234567/* /pattern/flags*/const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\\W?_$/gi; 在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。或者调用RegExp对象的构造函数，如下所示： 123456789/* new RegExp(pattern [, flags])*/let regex = new RegExp(&quot;ab+c&quot;);let regex = new RegExp(/^[a-zA-Z]+[0-9]*\\W?_$/, &quot;gi&quot;);let regex = new RegExp(&quot;^[a-zA-Z]+[0-9]*\\\\W?_$&quot;, &quot;gi&quot;); 使用构造函数提供正则表达式的运行时编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://137942170.github.io/fwtBlog/categories/JavaScript/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://137942170.github.io/fwtBlog/tags/正则/"}]},{"title":"第3期:(3)hexo部署多设备同步管理","slug":"第3期-3-hexo部署多设备同步管理","date":"2019-07-02T10:15:54.000Z","updated":"2019-07-11T02:03:32.962Z","comments":true,"path":"2019/07/02/第3期-3-hexo部署多设备同步管理/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/02/第3期-3-hexo部署多设备同步管理/","excerpt":"","text":"一、hexo部署多设备同步管理对于很多已经把项目部署到github来说已经可以发表文章了，但是想要执行多台电脑同时写文章并且操作还是有很多坑，看了网上很多文章总结下来的，一些坑 环境配置 安装 hexo 安装 Node 安装 git 这个不废话直接跳过 创建分支这个其实就是咱们正常使用github创建项目的流程了，首先咱们要确定的是就是要有两个分支，master 和 hexo, hexo 生成的静态博客文件都是上传到GitHub上的, 且默认放在 master 分支上, 而一些相关的配置文件都在本地,所以首先我们要创建hexo分支并且设置hexo为默认分支(更换电脑是直接 git clone hexo ) 切换到该hexo分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo，save保存 二、上传hexo源文件到服务器克隆hexo分支 在hexo分支创建完成以后，克隆hexo到本地，然后在命令行中执行,查看新建的分支为hexo 12$ git branch*hexo 上传部署文件 将本地博客的部署文件（Hexo目录下的全部文件）全部拷贝进刚clone的文件目录中去，需要将插件重新安装一遍 123456789101112131415npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --savenpm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 最后文件全部提交到Hexo分支 提交时注意事项 如果themes目录中主题中含有主题的.git文件，直接删除 最后用终端或者管理工具将所有文件提交到hexo分支 另外需要说明的是同步到其他电脑时需要将新电脑的生成的ssh key添加到GitHub账户上 master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突 本文参考出处","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://137942170.github.io/fwtBlog/categories/Hexo/"}],"tags":[{"name":"7月","slug":"7月","permalink":"https://137942170.github.io/fwtBlog/tags/7月/"}]},{"title":"第2期:(2)hexo标签插件的基础操作","slug":"第2期-2-hexo标签插件的基础操作","date":"2019-07-01T04:18:52.000Z","updated":"2019-07-19T08:38:16.034Z","comments":true,"path":"2019/07/01/第2期-2-hexo标签插件的基础操作/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/07/01/第2期-2-hexo标签插件的基础操作/","excerpt":"","text":"hexo标签插件的基础操作一、引用块1、普通输出小时候枕头上都是口水，长大以后枕头上都是泪水，小时候微笑是一种心情，长大后微笑是一种表情，小时候哭着哭着就笑了，长大后笑着笑着就哭了我们终于到了小时候最羡慕的年纪，但却没能成为小时候最想成为的人 2、引用书上的句子小时候枕头上都是口水，长大以后枕头上都是泪水，小时候微笑是一种心情，长大后微笑是一种表情，小时候哭着哭着就笑了，长大后笑着笑着就哭了我们终于到了小时候最羡慕的年纪，但却没能成为小时候最想成为的人 fwtFeng Feng 3、引用 TwitterNEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 4、引用网络上的文章小时候枕头上都是口水，长大以后枕头上都是泪水，小时候微笑是一种心情，长大后微笑是一种表情，小时候哭着哭着就笑了，长大后笑着笑着就哭了我们终于到了小时候最羡慕的年纪，但却没能成为小时候最想成为的人 Seth GodinWelcome to Island Marketing 二、代码块1、普通代码块1alert(&apos;Hello javascript!&apos;); 2、指定语言1[rectangle setX: 10 y: 10 width: 20 height: 20]; 3、附加内容Array.map1array.map(callback[, thisArg]) 4、附加网址_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 三、反引号代码块由于此处加载大量网址 暂且不做示例1、Pull Quote 引用123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; 2、jsFiddle1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; 3、Gist1&#123;% gist gist_id [filename] %&#125; 4、iframe1&#123;% iframe url [width] [height] %&#125; 5、Image1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 6、Link1&#123;% link text url [external] [title] %&#125; 7、Include Code1&#123;% include_code [title] [lang:language] path/to/file %&#125; 8、Youtube1&#123;% youtube video_id %&#125; 9、Vimeo1&#123;% vimeo video_id %&#125; 四、引用文章12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 五、引用资源123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 六、Raw123&#123;% raw %&#125;content&#123;% endraw %&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://137942170.github.io/fwtBlog/categories/Hexo/"}],"tags":[{"name":"md语法","slug":"md语法","permalink":"https://137942170.github.io/fwtBlog/tags/md语法/"},{"name":"7月","slug":"7月","permalink":"https://137942170.github.io/fwtBlog/tags/7月/"}]},{"title":"第1期:(1)hexo常用命令及markdown基础语法","slug":"markdown（md）文件的基本常用编辑语法","date":"2019-06-24T03:23:43.000Z","updated":"2019-07-12T06:19:48.366Z","comments":true,"path":"2019/06/24/markdown（md）文件的基本常用编辑语法/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/06/24/markdown（md）文件的基本常用编辑语法/","excerpt":"","text":"hexo常用命令1、分段:两个回车:1234 一个人会落泪，是因为痛；一个人之所以痛，是因为在乎；一个人之所以在乎，是因为有感觉； 一个人之所以有感觉，仅因为你是一个人！所以，你有感觉，在乎，痛过，落泪了，说明你是完整的一个人。难过的时候，原谅自己，你只不过是一个人而已，没必要把自己看的这么坚不可摧。 2、换行 两个空格 + 回车 :12 一个人之所以有感觉，仅因为你是一个人！所以，你有感觉，在乎，痛过，落泪了，说明你是完整的一个人。 难过的时候，原谅自己，你只不过是一个人而已，没必要把自己看的这么坚不可摧。 3、标题 # ~ ###### 井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题:H2: 一个人之所以有感觉，仅因为你是一个人！H3: 一个人之所以有感觉，仅因为你是一个人！H4: 一个人之所以有感觉，仅因为你是一个人！H5: 一个人之所以有感觉，仅因为你是一个人！H6: 一个人之所以有感觉，仅因为你是一个人！4、引用 &gt;: 一个人之所以有感觉，仅因为你是一个人！ 5、列表 * ， + ， - ， 1. ，选其中之一，注意后面有个空格: The reason why a person feels is because you are a person! The reason why a person feels is because you are a person! The reason why a person feels is because you are a person! The reason why a person feels is because you are a person! The reason why a person feels is because you are a person! The reason why a person feels is because you are a person! 6、代码区块 四个空格 开头:1The reason why a person feels is because you are a person! 7、链接:[文字](链接地址) 8、图片:![](图片地址) //图片地址可以是本地路劲，也可以是网络地址 9、强调:字体删除字体删除字体删除字体删除字体删除 10、代码:1The reason why a person feels is because you are a person! 11、字体及颜色用法: 我是黑体字我是黑体字我是微软雅黑我是华文彩云黑体nullgray 12、代码段:The reason why a person feels is because you are a person! 13、JavaScript 示例:123456789/*** nth element in the fibonacci series.*/function fib(n) &#123; var a = 1, b = 1; return a;&#125;document.write(fib(10)); 14、表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://137942170.github.io/fwtBlog/categories/Hexo/"}],"tags":[{"name":"6月","slug":"6月","permalink":"https://137942170.github.io/fwtBlog/tags/6月/"},{"name":"md语法","slug":"md语法","permalink":"https://137942170.github.io/fwtBlog/tags/md语法/"}]},{"title":"使用github pages服务搭建博客的好处","slug":"first-myblog","date":"2019-06-24T03:18:40.000Z","updated":"2019-07-11T02:03:48.161Z","comments":true,"path":"2019/06/24/first-myblog/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/06/24/first-myblog/","excerpt":"","text":"前言 使用github pages服务搭建博客的好处有： 1. 全是静态文件，访问速度快； 2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； &lt;!--more--&gt; 4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 5. 博客内容可以轻松打包、转移、发布到其它平台； 6. 等等；","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://137942170.github.io/fwtBlog/categories/Hexo/"}],"tags":[{"name":"6月","slug":"6月","permalink":"https://137942170.github.io/fwtBlog/tags/6月/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-20T08:46:08.828Z","updated":"2019-06-20T08:46:08.830Z","comments":true,"path":"2019/06/20/hello-world/","link":"","permalink":"https://137942170.github.io/fwtBlog/2019/06/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}